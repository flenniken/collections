#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script is for testing the login flow that Collections uses.

The basic flow:

  * Use -l to get the login url.
  * Paste the login url in your browser and login, you will be redirected.
  * Copy the code in the url in your browser's address bar.
  * Use -g option specifying the code. This creates the tokens.json file.
  * Use -s to look at the tokens file.
  * Use -d id_token, -d access_token, -d refresh_token, to peer into each token.
"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap
import pprint

# The token file created by the -g option. Used by some of the other options.
tokenFilename = "tmp/tokens.json"

class LoginFlowException(Exception):
  """ An exception we plan for. """
  pass

def printError(*args, **kwargs):
  """ Print message to standard error. """
  print(*args, file=sys.stderr, **kwargs)

def createFile(filename, content):
  """
  Create a file with the given content.
  """
  with open(filename, "w") as fp:
    fp.write(content)

def runJqLess(jsonText):
  """
  Launch less to view the specified json. The jq command formats
  and colors it.
  """
  # Run json data through jq.
  utf8Bytes = jsonText.encode('utf-8')
  try:
    result = subprocess.run(['jq', '-C'], stdout=subprocess.PIPE, input=utf8Bytes)
    utf8Bytes = result.stdout
  except:
    # If the json text is not valid json, we pass the text unchanged
    # to the less command below.
    pass

  # Launch less.
  try:
    result = subprocess.run(['less', '-F', '-R', '-X', '-K'], input=utf8Bytes)
  except KeyboardInterrupt:
    pass

def getAwsParameters(filename=None):
  """
  Return a namedtuple containing the aws settings.  If you don't
  pass in the filename, the aws-settings.json file is used.
  """

  # edit me when [aws_settings.json] changes
  requiredParameters = [
    'client_id',
    'redirect_uri',
    'logout_uri',
    'scope',
    'domain',
    'redirect_uri_local',
    'logout_uri_local',
    'pool_name',
    'distribution_id',
    'bucket_name',
  ]

  if filename and not os.path.exists(filename):
      raise LoginFlowException(f"""\
The aws settings file is missing. You can create it by running: scripts/cognito -w""")

  if filename is None:
    filename = "/home/coder/collections/env/aws-settings.json"

  # Read the Cognito parameters from the file.
  awsSettings = readJsonFile(filename)

  if "settings" not in awsSettings:
    raise LoginFlowException("Aws settings is missing the settings parameter.")

  settings = awsSettings['settings']

  # Make sure all the parameters we need exist.
  for parameter in requiredParameters:
    if parameter not in settings:
      raise LoginFlowException(f"Missing aws settings parameter: {parameter}.")

  AwsParameters = namedtuple('AwsParameters', settings)

  # edit me when [aws_settings.json] changes
  return AwsParameters(
    client_id=settings["client_id"],
    redirect_uri=settings["redirect_uri"],
    logout_uri=settings["logout_uri"],
    scope=settings["scope"],
    domain=settings["domain"],
    redirect_uri_local=settings["redirect_uri_local"],
    logout_uri_local=settings["logout_uri_local"],
    pool_name=settings["pool_name"],
    distribution_id=settings["distribution_id"],
    bucket_name=settings["bucket_name"],
  )

def showLoginUrl():
  url = getLoginUrl()
  print(f"""\

Enter the following url into your browser to login.  After logging in
it will redirect to the redirect_uri which will contain a code and a
state of "loggedInTest". You have a few minutes to use the code to get
tokens with the -g option.

{url}

""")

def getLoginUrl():
  """
  Return the login url.
  """
  params = getAwsParameters()
  return f"{params.domain}/oauth2/authorize?client_id={params.client_id}&state=loggedInTest&\
response_type=code&scope={urllib.parse.quote(params.scope)}\
&redirect_uri={params.redirect_uri}"

def getLogoutUrl():
  """
  Return the logout url.
  """
  params = getAwsParameters()
  return f"{params.domain}/logout?client_id={params.client_id}&state=loggedOut&\
logout_uri={params.logout_uri}"

def showLogoutUrl():
  """
  Print out the logout url.
  """
  url = getLogoutUrl()
  print(f"""\

Enter the following url into your browser to logout.  After logging
out it will redirect to the logout_uri which will contain a state of
"loggedOut".

{url}

""")

def readJsonFile(filename):
  """
  Read the given json file and return a dictionary.
  """
  if (not os.path.exists(filename)):
    raise LoginFlowException(f"The json file doesn't exist: '{filename}'.")

  try:
    with open(filename) as fp:
      fileData = fp.read()
  except Exception as ex:
    raise LoginFlowException("Unable to open the json file.")

  try:
    data = json.loads(fileData)
  except Exception as ex:
    raise LoginFlowException("Invalid json file data.")

  return data

def readJsonKey(filename, key):
  """
  Read the given json file and return the specified key's value.
  """
  data = readJsonFile(filename)
  if key not in data:
    raise LoginFlowException(f"The key '{key}' doesn't exist in the json data.")
  return data[key]

def getDecodeToken(tokenFilename, tokenName):
  """
  Read the given json file and return the specified token's decoded json.
  """
  token = readJsonKey(tokenFilename, tokenName)
  return decodeToken(token)

def decodeToken(tokenString):
  # Decode the token string and return json.
  try:
    jdata = jwt.decode(tokenString, algorithms=["RS256"], options={"verify_signature": False})
  except Exception as ex:
    raise LoginFlowException(f"Unable to decode the token. jwt returns:\n{str(ex)}")
  return(jdata)

def getUserInfo():
  """
  Get the user information from the access token.
  """
  # Get user info from the cognito oauth2/userInfo endpoint. See:
  # https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html

  # Create the token url.
  params = getAwsParameters()
  url = f"{params.domain}/oauth2/userInfo"
  print(f"url: '{url}'")

  access_token = readJsonKey(tokenFilename, "access_token")

  # Post to the userInfo url.
  headers = {"Authorization": f"Bearer {access_token}"}
  response = requests.get(url, headers=headers)

  # Display the result in the less command.
  runJqLess(response.text)

def getTokens(code=None, refresh=False):
  """
  Get new tokens using a code or using the refresh token in the tokens.json
  file. Overwrite the file with the new tokens.
  """
  # Post to the cognito oauth2/token endpoint. Save the result in a file. See:
  # https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html

  if not code and not refresh:
    raise LoginFlowException("Pass a code or specify refresh.")

  if refresh:
    refresh_token = readJsonKey(tokenFilename, "refresh_token")

  # Create the token url.
  params = getAwsParameters()
  url = f"{params.domain}/oauth2/token"

  # Post to the token url.
  headers = {"Content-type": "application/x-www-form-urlencoded"}
  if refresh:
    data = {
      "grant_type": "refresh_token",
      "client_id": params.client_id,
      "refresh_token": refresh_token,
    }
  else:
    data = {
      "grant_type": "authorization_code",
      "client_id": params.client_id,
      "redirect_uri": params.redirect_uri,
      "code": code,
    }

  print(f"/oauth2/token url: '{url}'")
  # print("headers:")
  # pprint.pp(headers)
  # print("data:")
  # pprint.pp(data)

  response = requests.post(url, data=data, headers=headers)

  if response.status_code != 200:
    print(f"""Coginto responded with status code: {response.status_code}
The file was not written. Response text:""")
    print(response.text)
    return

  # Write the tokens returned to a file.
  result = response.text
  with open(tokenFilename, 'w') as fp:
    fp.write(result)

  # Tell how to read the tokens.
  print(f"""\
Wrote the tokens to {tokenFilename}.

You can use the following options to look at and use the tokens.

  -s -- look at the file in the less command or:
    cat {tokenFilename} | jqless

  -d -- decode one of the tokens in the file. Similar to jwt.io.

  -u -- use the access_token in the file to get the user information
   from cognito. You have about an hour before the access_token
   expires.

  -r -- refresh the tokens using the refresh token.

  -k -- revoke the tokens.
""")

def revokeTokens():
  """
  This revokes current and future access and identity tokens given
  the refresh token in the tokens.json file.
  """
  # Create the token url.
  params = getAwsParameters()
  url = f"{params.domain}/oauth2/revoke"
  print(f"url: '{url}'")

  refresh_token = readJsonKey(tokenFilename, "refresh_token")
  headers = {"Content-type": "application/x-www-form-urlencoded"}
  data = {
    "token": refresh_token,
    "client_id": params.client_id,
  }
  response = requests.post(url, data=data, headers=headers)
  print(f"""Coginto responded with status code: {response.status_code}
Response text:""")
  runJqLess(response.text)

def showDecodedToken(tokenName):
  tokenNames = ['access_token', 'id_token', 'refresh_token']
  if tokenName not in tokenNames:
    raise LoginFlowException(f"Invalid token name, specify one of: {tokenNames}.")
  data = getDecodeToken(tokenFilename, tokenName)
  jData = json.dumps(data)
  runJqLess(jData)

def showTokens():
  """
  Show the token file.
  """
  with open(tokenFilename) as fp:
    text = fp.read()
  runJqLess(text)

def process(args):
  """
  """
  if args.showLoginUrl:
    showLoginUrl()
  elif args.showLogoutUrl:
    showLogoutUrl()
  elif args.getTokens:
    getTokens(code=args.getTokens, refresh=False)
  elif args.showTokens:
    showTokens()
  elif args.decodeToken:
    showDecodedToken(args.decodeToken)
  elif args.getUserInfo:
    getUserInfo()
  elif args.refreshTokens:
    getTokens(code=None, refresh=True)
  elif args.revokeTokens:
    revokeTokens()
  else:
    showHelp()

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")
  parser.add_argument("-l", "--showLoginUrl", action="store_true",
    help="show the login url (oauth2/authorize endpoint)")
  parser.add_argument("-o", "--showLogoutUrl", action="store_true",
    help="show the logout url (logout endpoint)")
  parser.add_argument("-g", "--getTokens", metavar="code",
    help=f"get the cognito tokens (oauth2/token endpoint) and write them to {tokenFilename}. Specify a login code.")
  parser.add_argument("-s", "--showTokens", action="store_true",
    help=f"show the {tokenFilename} file")
  parser.add_argument("-d", "--decodeToken", metavar='token',
    help=f"""decode a token from the {tokenFilename} file, specify id_token,
    access_token, or refresh_token""")
  parser.add_argument("-u", "--getUserInfo", action="store_true",
    help=f"show the user information (oauth2/userInfo endpoint) given an access token in {tokenFilename}.")
  parser.add_argument("-r", "--refreshTokens", action="store_true",
    help=f"get a new access and id token but not a refresh token (oauth2/token endpoint). It uses the refresh token in {tokenFilename} and overwrites the file with the new tokens. Since the refresh token is not in the file, calling refresh again will fail.")
  parser.add_argument("-k", "--revokeTokens", action="store_true",
    help=f"revoke the refresh token (oauth2/revoke endpoint) in {tokenFilename} and its related tokens")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except LoginFlowException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

class TestLoginFlow(unittest.TestCase):

  def test_me(self):
    self.assertEqual(True, bool(1))
    self.assertEqual(False, bool(0))

  def test_getLoginUrl(self):
    url = getLoginUrl()
    # print(url)
    self.assertTrue(url.startswith("https://"))
    self.assertTrue("/oauth2/authorize?client_id=" in url)
    self.assertTrue("state=loggedIn" in url)

  def test_getLogoutUrl(self):
    url = getLogoutUrl()
    # print(url)
    self.assertTrue(url.startswith("https://"))
    self.assertTrue("/logout?client_id=" in url)
    self.assertTrue("state=loggedOut" in url)

  def test_getAwsParameters(self):
    # Test happy path.
    filename = "tmp/test_getAwsParameters.txt"

    # edit me when [aws_settings.json] changes
    content = """\
{
  "settings": {
    "client_id": "the client_id",
    "redirect_uri": "the redirect_uri",
    "logout_uri": "the logout_uri",
    "scope": "the scope",
    "domain": "the domain",
    "redirect_uri_local": "the redirect_uri_local",
    "logout_uri_local": "the logout_uri_local",
    "pool_name": "the pool_name",
    "distribution_id": "the distribution_id",
    "bucket_name": "the bucket_name"
  }
}
"""
    createFile(filename, content)
    params = getAwsParameters(filename)
    os.remove(filename)

    # print("Cognito Parameters:")
    # for name, value in params._asdict().items():
    #   print(f"{name}: {value}")

    # edit me when [aws_settings.json] changes
    self.assertEqual(params.client_id, "the client_id")
    self.assertEqual(params.redirect_uri, "the redirect_uri")
    self.assertEqual(params.logout_uri, "the logout_uri")
    self.assertEqual(params.scope, "the scope")
    self.assertEqual(params.domain, "the domain")
    self.assertEqual(params.redirect_uri_local, "the redirect_uri_local")
    self.assertEqual(params.logout_uri_local, "the logout_uri_local")
    self.assertEqual(params.pool_name, "the pool_name")
    self.assertEqual(params.distribution_id, "the distribution_id")
    self.assertEqual(params.bucket_name, "the bucket_name")

  def test_getAwsParameters_error1(self):
    with self.assertRaises(LoginFlowException) as context:
      params = getAwsParameters("missing")
    expected = "The aws settings file is missing. You can create it by running: scripts/cognito -w"
    self.assertEqual(str(context.exception), expected)

  def test_getAwsParameters_error(self):
    filename = "tmp/test_getAwsParameters_error.txt"
    content = """{"domain": "the domain"}"""
    createFile(filename, content)
    with self.assertRaises(LoginFlowException) as context:
      params = getAwsParameters(filename)
    os.remove(filename)
    self.assertEqual(str(context.exception), "Aws settings is missing the settings parameter.")

  def test_getAwsParameters_error2(self):
    filename = "tmp/test_getAwsParameters_error.txt"
    content = """{"settings": "asdf"}"""
    createFile(filename, content)
    with self.assertRaises(LoginFlowException) as context:
      params = getAwsParameters(filename)
    os.remove(filename)
    self.assertEqual(str(context.exception), "Missing aws settings parameter: client_id.")

  def test_readJsonKey(self):
    content = """\
{
  "name": "Steve",
  "flower": "rose"
}
"""
    filename = "tmp/readJsonKey.json"
    createFile(filename, content)
    value = readJsonKey(filename, "name")
    # print(value)
    self.assertEqual(value, "Steve")
    os.remove(filename)

  def test_readJsonKey_error(self):
    filename = "tmp/readJsonKey_error.json"
    createFile(filename, """{"name": "Steve",}""")

    with self.assertRaises(LoginFlowException) as context:
      value = readJsonKey(filename, "name")

    os.remove(filename)

    self.assertEqual(str(context.exception), "Invalid json file data.")

  def test_readJsonKey_error2(self):
    with self.assertRaises(LoginFlowException) as context:
      value = readJsonKey("missingfile", "name")
    self.assertEqual(str(context.exception), """The json file doesn't exist: 'missingfile'.""")

  def test_readJsonKey_error3(self):
    filename = "tmp/readJsonKey_error3.json"
    createFile(filename, """{"name": "Steve"}""")
    with self.assertRaises(LoginFlowException) as context:
      value = readJsonKey(filename, "notkey")
    os.remove(filename)
    self.assertEqual(str(context.exception), "The key 'notkey' doesn't exist in the json data.")

  def test_getDecodeToken(self):
    content = """{
    "access_token": "eyJraWQiOiJieEtvVmw5K2hBKzRpV1IrWUtCdFVsbVNheVNPUklCUzZNRFhoYWQ4dHVrPSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiIyODkxOTNiMC0xMDAxLTcwMTYtNGQzNC1iNjMxYzY5M2RkYTEiLCJpc3MiOiJodHRwczpcL1wvY29nbml0by1pZHAudXMtd2VzdC0yLmFtYXpvbmF3cy5jb21cL3VzLXdlc3QtMl9MbTJsdTZvY1giLCJ2ZXJzaW9uIjoyLCJjbGllbnRfaWQiOiIxaDFlbWtkNHBvZjN2YWNsZTJhbGJnajJxbiIsIm9yaWdpbl9qdGkiOiIwZDM1ZTFlNy05YWVmLTRhNDgtODBhYi02NDc2YjQ4MzVjNmUiLCJldmVudF9pZCI6IjBkZGIzMmY4LTRmMTUtNGM2ZC1hM2I1LTliZmUzYTIzMmRjZiIsInRva2VuX3VzZSI6ImFjY2VzcyIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUiLCJhdXRoX3RpbWUiOjE3MTY1ODEyNzIsImV4cCI6MTcxNjU4NDg3MiwiaWF0IjoxNzE2NTgxMjcyLCJqdGkiOiJjNzMxNjE5MC1kNjAzLTQyMGItOTM5Yy0zZTFiNjVlZDU3OGQiLCJ1c2VybmFtZSI6IjI4OTE5M2IwLTEwMDEtNzAxNi00ZDM0LWI2MzFjNjkzZGRhMSJ9.ygyyNnJlDDlY3KKYJu9-yfkI3F2PFVGy44_oIMlWFcPiS7b-IHuDeBpBMlkRhYG_PD4h7HIRp-39UQuuC0gJX4Z3nRIFg49lj4i3h-dsx3gsgNjFPG-MGwWZYJoALK_2PiEqyq4zOl_3Szy5CPRXOXqIwvMKhTtz6l9Saaa-y5zSL_TygF1Y5ZRHiWfGDKIwCdZD5asjuwZa6ZT2FiD-3dARN2OngH7CX9omohcrUPSwyhedFMtKbA4AeCW8y_hhHQFcc_PoI4S80DXBvECzcKvc_GQUPx2fCwGxfE__i57iZVzzhZKrtqXc9Ndoy_ka4T7jVa60DQ_-Jb51rprRVg"
}
"""
    filename = "tmp/getDecodeToken.json"
    createFile(filename, content)
    data = getDecodeToken(filename, "access_token")
    os.remove(filename)

    # print(data)
    # for k, v in data.items():
    #   print(f"'{k}', ", end="")

    # for k, v in data.items():
    #   print(f"{k: >10}: {v}")

    keys = ['sub', 'iss', 'version', 'client_id', 'origin_jti',
            'event_id', 'token_use', 'scope', 'auth_time', 'exp',
            'iat', 'jti', 'username']
    for key in keys:
      if key not in data:
        print(f"missing key: 'key'")
        self.assertTrue(false)

    self.assertEqual(data['scope'], "openid profile")

  def test_readJsonFile(self):
    filename = "tmp/test_readJsonFile.json"
    contents = """\
{
  "a": 5
}
"""
    createFile(filename, contents)
    data = readJsonFile(filename)
    self.assertEqual(data["a"], 5)
    os.remove(filename)

  def test_readJsonFile_error(self):
    with self.assertRaises(LoginFlowException) as context:
      data = readJsonFile("missing")
    self.assertEqual(str(context.exception), "The json file doesn't exist: 'missing'.")

  def test_readJsonFile_error2(self):
    filename = "tmp/test_readJsonFile_error2.json"
    contents = """\
{
  "a": 5, error
}
"""
    createFile(filename, contents)
    with self.assertRaises(LoginFlowException) as context:
      data = readJsonFile(filename)
    self.assertEqual(str(context.exception), "Invalid json file data.")
    os.remove(filename)

  def test_decodeToken(self):
    tokenString = "eyJraWQiOiIzZ0pzTmNjVnEzYTRNK1JQRmNUcHptU1ZDc3BSemYya\
UdLbVQ4WjJHdWFBPSIsImFsZyI6IlJTMjU2In0.eyJhdF9oYXNoIjoiMzQ0eFFRQkZkOXBtYm\
ViZlA1bjh2USIsInN1YiI6IjI4OTE5M2IwLTEwMDEtNzAxNi00ZDM0LWI2MzFjNjkzZGRhMSIs\
ImN1c3RvbTphZG1pbiI6IjEiLCJpc3MiOiJodHRwczpcL1wvY29nbml0by1pZHAudXMtd2VzdC0\
yLmFtYXpvbmF3cy5jb21cL3VzLXdlc3QtMl9MbTJsdTZvY1giLCJjb2duaXRvOnVzZXJuYW1lIjo\
iMjg5MTkzYjAtMTAwMS03MDE2LTRkMzQtYjYzMWM2OTNkZGExIiwiZ2l2ZW5fbmFtZSI6IlN0ZXZl\
Iiwib3JpZ2luX2p0aSI6IjE2ZTM4YmM4LTlhN2ItNDUwMC1hYTMyLTA2NmQzYmY1M2EyZCIsImF1ZC\
I6IjFoMWVta2Q0cG9mM3ZhY2xlMmFsYmdqMnFuIiwiZXZlbnRfaWQiOiI2MGQ4YTlkNC01OTE2LTQwZ\
mQtOTM1MC0xZmM3ZTFmNzk0NjgiLCJ0b2tlbl91c2UiOiJpZCIsImF1dGhfdGltZSI6MTcxNjc0ODE1M\
CwiZXhwIjoxNzE2NzUxNzUwLCJpYXQiOjE3MTY3NDgxNTAsImZhbWlseV9uYW1lIjoiRmxlbm5pa2VuIi\
wianRpIjoiMTIyZmU5MGUtYjU4Yi00NzlmLWE0ZWQtYTA2ZDg4N2Y3OGYxIiwiZW1haWwiOiJzdGV2ZS5m\
bGVubmlrZW5AZ21haWwuY29tIn0.jrFF11SXYpHIp9YMCiKngkahmcgCjYvaTgjmy5RwGjpa7l8jFJFf-mI\
D45WJoKC4iKcrdQL0sR4NRWzt74tnoBU2czCl_wB4OUq93JKakncmgMEqCOCO6Yq3eG99fKf1ARfJQ8Aa_N4\
Qx4B3DwbtsoI7NkBhFao6vXwU49HSixMkExcbB9DDVPGLrhxDBveDmATsDPb-jElDSQtqrpF8fiw6QHxKo3UJ\
P8Is_e72DOsWOpiLhciZglMPjO2HR_ZF6FQL1zsklykVyzvR9y_W9FC8SjB6fvYghV2GjJ0PP_nxr_GKHkPHK8\
NGItumhDXKXoHvjwD-5s2qiJQ2xHDptw"
    data = decodeToken(tokenString)
    self.assertTrue("at_hash" in data)
    self.assertTrue("given_name" in data)
    self.assertTrue("family_name" in data)
    self.assertTrue("email" in data)
    self.assertTrue("custom:admin" in data)

  def test_decodeToken_error(self):
    with self.assertRaises(LoginFlowException) as context:
      decodeToken("not a token")
    self.assertEqual(str(context.exception), """\
Unable to decode the token. jwt returns:
Not enough segments""")

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
