#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script is for testing the login flow that Collections uses.

The basic flow:

  * Use -l to get the login url.
  * Paste the login url in your browser and login, you will be redirected.
  * Copy the code in the url in your browser's address bar.
  * Use -g option specifying the code. This creates the tokens.json file.
  * Use -s to look at the tokens file.
  * Use -d id_token, -d access_token, -d refresh_token, to peer into each token.
"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap

# The token file created by the -g option. Used by some of the other options.
tokenFilename = "tmp/tokens.json"

class LoginFlowException(Exception):
  """ An exception we plan for. """
  pass

def createFile(filename, content):
  """
  Create a file with the given content.
  """
  with open(filename, "w") as fp:
    fp.write(content)

def getCognitoParameters(filename=None):
  """
  Return a namedtuple containing the AWS Cognito parameters,
  client_id etc. If you don't pass in the filename, the
  /home/coder/.aws/cognito-config file is used.
  """
  requiredParameters = ['domain', 'client_id', 'redirect_uri',
    'logout_uri', 'scope',]

  if filename is None:
    filename = "/home/coder/.aws/cognito-config"

  # Read the Cognito parameters from the file.
  cognitoParameters = readJsonFile(filename)

  # Make sure all the parameters we need exist.
  for parameter in requiredParameters:
    if parameter not in cognitoParameters:
      raise LoginFlowException(f"Missing cognito config parameter: {parameter}.")

  CognitoParameters = namedtuple('CognitoParameters', cognitoParameters)
  return CognitoParameters(
    domain=cognitoParameters["domain"],
    client_id=cognitoParameters["client_id"],
    redirect_uri=cognitoParameters["redirect_uri"],
    logout_uri=cognitoParameters["logout_uri"],
    scope=cognitoParameters["scope"],
  )

def showLoginUrl():
  """
  Print out the login url.
  """
  params = getCognitoParameters()

  print("""\

Enter the following url into your browser to login.  After logging in
it will redirect to the redirect_uri which will contain a code and a
state of "loggedIn". You have a few minutes to use the code to get
tokens with the -g option.

""")

  url = f"{params.domain}/oauth2/authorize?client_id={params.client_id}&state=loggedIn&\
response_type=code&scope={urllib.parse.quote(params.scope)}&redirect_uri={params.redirect_uri}"
  print(url)
  print()

def showLogoutUrl():
  """
  Print out the logout url.
  """
  params = getCognitoParameters()

  print("""\

Enter the following url into your browser to logout.  After logging
out it will redirect to the logout_uri which will contain a state of
"loggedOut".
""")

  url = f"{domain}/logout?client_id={params.client_id}&state=loggedOut&\
logout_uri={params.logout_uri}"
  print(url)
  print()

def readJsonFile(filename):
  """
  Read the given json file and return a dictionary.
  """
  if (not os.path.exists(filename)):
    raise LoginFlowException(f"The json file doesn't exist.")

  try:
    with open(filename) as fp:
      fileData = fp.read()
  except Exception as ex:
    raise LoginFlowException("Unable to open the json file.")

  try:
    data = json.loads(fileData)
  except Exception as ex:
    raise LoginFlowException("Invalid json file data.")

  return data

def readJsonKey(filename, key):
  """
  Read the given json file and return the specified key's value.
  """
  data = readJsonFile(filename)
  if key not in data:
    raise LoginFlowException(f"The key '{key}' doesn't exist in the json data.")
  return data[key]

def getDecodeToken(tokenFilename, tokenName):
  """
  Read the given json file and return the specified token's decoded json.
  """
  token = readJsonKey(tokenFilename, tokenName)

  # Decode the token but don't verify it.
  try:
    jdata = jwt.decode(token, algorithms=["RS256"], options={"verify_signature": False})
  except Exception as ex:
    raise LoginFlowException(f"Unable to decode the token. jwt returns:\n{str(ex)}")
  return(jdata)

def getUserInfo():
  """
  Get the user information from the access token.
  """
  # Get user info from the cognito oauth2/userInfo endpoint. See:
  # https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html

  # Create the token url.
  params = getCognitoParameters()
  url = f"{params.domain}/oauth2/userInfo"
  print(f"url: '{url}'")

  access_token = readJsonKey(tokenFilename, "access_token")

  # Post to the userInfo url.
  headers = {"Authorization": f"Bearer {access_token}"}
  response = requests.get(url, headers=headers)

  # Display the result in the less command.
  runJqLess(response.text)

def getTokens(code=None, refresh=False):
  """
  Get new tokens using a code or using the refresh token in the tokens.json
  file. Overwrite the file with the new tokens.
  """
  # Post to the cognito oauth2/token endpoint. Save the result in a file. See:
  # https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html

  if not code and not refresh:
    raise LoginFlowException("Pass a code or specify refresh.")

  if refresh:
    refresh_token = readJsonKey(tokenFilename, "refresh_token")

  # Create the token url.
  params = getCognitoParameters()
  url = f"{params.domain}/oauth2/token"
  print(f"url: '{url}'")

  # Post to the token url.
  headers = {"Content-type": "application/x-www-form-urlencoded"}
  if refresh:
    data = {
      "grant_type": "refresh_token",
      "client_id": params.client_id,
      "refresh_token": refresh_token,
    }
  else:
    data = {
      "grant_type": "authorization_code",
      "client_id": params.client_id,
      "redirect_uri": params.redirect_uri,
      "code": code,
    }

  response = requests.post(url, data=data, headers=headers)

  if response.status_code != 200:
    print(f"""Coginto responded with status code: {response.status_code}
The file was not written. Response text:""")
    runJqLess(response.text)
    return

  # Write the tokens returned to a file.
  result = response.text
  with open(tokenFilename, 'w') as fp:
    fp.write(result)

  # Tell how to read the tokens.
  print(f"""\
Wrote the tokens to {tokenFilename}.

You can use the following options to look at and use the tokens.

  -s -- look at the file in the less command or:
    cat {tokenFilename} | jq -C | less -R

  -d -- decode one of the tokens in the file. Similar to jwt.io.

  -u -- use the access_token in the file to get the user information
   from cognito. You have about an hour before the access_token
   expires.

  -r -- refresh the tokens using the refresh token.

  -k -- revoke the tokens.
""")

def revokeTokens():
  """
  This revokes current and future access and identity tokens given
  the refresh token in the tokens.json file.
  """
  # Create the token url.
  params = getCognitoParameters()
  url = f"{params.domain}/oauth2/revoke"
  print(f"url: '{url}'")

  refresh_token = readJsonKey(tokenFilename, "refresh_token")
  headers = {"Content-type": "application/x-www-form-urlencoded"}
  data = {
    "token": refresh_token,
    "client_id": params.client_id,
  }
  response = requests.post(url, data=data, headers=headers)
  print(f"""Coginto responded with status code: {response.status_code}
Response text:""")
  runJqLess(response.text)

def showDecodedToken(tokenName):
  tokenNames = ['access_token', 'id_token', 'refresh_token']
  if tokenName not in tokenNames:
    raise ServicesExpection(f"Invalid token name, specify one of: {tokenNames}")
  data = getDecodeToken(tokenFilename, tokenName)
  jData = json.dumps(data)
  runJqLess(jData)

def showTokens():
  """
  Show the token file.
  """
  with open(tokenFilename) as fp:
    text = fp.read()
  runJqLess(text)

def runJqLess(jsonText):
  """
  Launch less to view the specified json. The jq command formats
  and colors it.
  """
  # Run json data through jq.
  utf8Bytes = jsonText.encode('utf-8')
  try:
    result = subprocess.run(['jq', '-C'], stdout=subprocess.PIPE, input=utf8Bytes)
    utf8Bytes = result.stdout
  except:
    # If the json text is not valid json, we pass the text unchanged
    # to the less command below.
    pass

  # Launch less.
  try:
    result = subprocess.run(['less', '-F', '-R', '-X', '-K'], input=utf8Bytes)
  except KeyboardInterrupt:
    pass

def process(args):
  """
  """
  if args.login:
    showLoginUrl()
  elif args.logout:
    showLogoutUrl()
  elif args.getTokens:
    getTokens(code=args.getTokens, refresh=False)
  elif args.showTokens:
    showTokens()
  elif args.decodeToken:
    showDecodedToken(args.decodeToken)
  elif args.getUserInfo:
    getUserInfo()
  elif args.refreshTokens:
    getTokens(code=None, refresh=True)
  elif args.revokeTokens:
    revokeTokens()
  else:
    showHelp()

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  # parser = argparse.ArgumentParser(description= __doc__)

  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")
  parser.add_argument("-l", "--login", action="store_true",
    help="show the login url (login endpoint)")
  parser.add_argument("-o", "--logout", action="store_true",
    help="show the logout url (logout endpoint)")
  parser.add_argument("-g", "--getTokens", metavar="code",
    help=f"get the cognito tokens (oauth2/token endpoint) and write them to {tokenFilename}. Specify a login code.")
  parser.add_argument("-s", "--showTokens", action="store_true",
    help=f"show the {tokenFilename} file")
  parser.add_argument("-d", "--decodeToken", metavar='token',
    help=f"""decode a token from the {tokenFilename} file, specify id_token,
    access_token, or refresh_token""")
  parser.add_argument("-u", "--getUserInfo", action="store_true",
    help=f"show the user information (oauth2/userInfo endpoint) given an access token in {tokenFilename}.")
  parser.add_argument("-r", "--refreshTokens", action="store_true",
    help=f"get a new access and id token but not a refresh token (oauth2/token endpoint). It uses the refresh token in {tokenFilename} and overwrites the file with the new tokens. Since the refresh token is not in the file, calling refresh again will fail.")
  parser.add_argument("-k", "--revokeTokens", action="store_true",
    help=f"revoke the refresh token (oauth2/revoke endpoint) in {tokenFilename} and its related tokens")

  args = parser.parse_args(sys.argv[1:])
  return args

def printError(*args, **kwargs):
  """ Print message to standard error. """
  print(*args, file=sys.stderr, **kwargs)

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except LoginFlowException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

class TestLoginFlow(unittest.TestCase):

  def test_me(self):
    self.assertEqual(True, bool(1))
    self.assertEqual(False, bool(0))

  def test_getCognitoParameters(self):
    filename = "tmp/test_getCognitoParameters.txt"
    content = """{\
"domain": "the domain",
"client_id": "the client_id",
"redirect_uri": "the redirect_uri",
"logout_uri": "the logout_uri",
"scope": "the scope"
}
"""
    createFile(filename, content)
    params = getCognitoParameters(filename)
    os.remove(filename)

    # print("Cognito Parameters:")
    # for name, value in params._asdict().items():
    #   print(f"{name}: {value}")
    self.assertEqual(params.domain, "the domain")
    self.assertEqual(params.client_id, "the client_id")
    self.assertEqual(params.redirect_uri, "the redirect_uri")
    self.assertEqual(params.logout_uri, "the logout_uri")
    self.assertEqual(params.scope, "the scope")

  def test_getCognitoParameters_error1(self):
    with self.assertRaises(LoginFlowException) as context:
      params = getCognitoParameters("missing")
    self.assertEqual(str(context.exception), "The json file doesn't exist.")

  def test_getCognitoParameters_error(self):
    filename = "tmp/test_getCognitoParameters_error.txt"
    content = """{"domain": "the domain"}"""
    createFile(filename, content)
    with self.assertRaises(LoginFlowException) as context:
      params = getCognitoParameters(filename)
    os.remove(filename)
    self.assertEqual(str(context.exception), "Missing cognito config parameter: client_id.")

  def test_readJsonKey(self):
    content = """\
{
  "name": "Steve",
  "flower": "rose"
}
"""
    filename = "tmp/readJsonKey.json"
    createFile(filename, content)
    value = readJsonKey(filename, "name")
    # print(value)
    self.assertEqual(value, "Steve")
    os.remove(filename)

  def test_readJsonKey_error(self):
    filename = "tmp/readJsonKey_error.json"
    createFile(filename, """{"name": "Steve",}""")

    with self.assertRaises(LoginFlowException) as context:
      value = readJsonKey(filename, "name")

    os.remove(filename)

    self.assertEqual(str(context.exception), "Invalid json file data.")

  def test_readJsonKey_error2(self):
    with self.assertRaises(LoginFlowException) as context:
      value = readJsonKey("missingfile", "name")
    self.assertEqual(str(context.exception), """The json file doesn't exist.""")

  def test_readJsonKey_error3(self):
    filename = "tmp/readJsonKey_error3.json"
    createFile(filename, """{"name": "Steve"}""")
    with self.assertRaises(LoginFlowException) as context:
      value = readJsonKey(filename, "notkey")
    os.remove(filename)
    self.assertEqual(str(context.exception), "The key 'notkey' doesn't exist in the json data.")

  def test_getDecodeToken(self):
    content = """{
    "access_token": "eyJraWQiOiJieEtvVmw5K2hBKzRpV1IrWUtCdFVsbVNheVNPUklCUzZNRFhoYWQ4dHVrPSIsImFsZyI6IlJTMjU2In0.eyJzdWIiOiIyODkxOTNiMC0xMDAxLTcwMTYtNGQzNC1iNjMxYzY5M2RkYTEiLCJpc3MiOiJodHRwczpcL1wvY29nbml0by1pZHAudXMtd2VzdC0yLmFtYXpvbmF3cy5jb21cL3VzLXdlc3QtMl9MbTJsdTZvY1giLCJ2ZXJzaW9uIjoyLCJjbGllbnRfaWQiOiIxaDFlbWtkNHBvZjN2YWNsZTJhbGJnajJxbiIsIm9yaWdpbl9qdGkiOiIwZDM1ZTFlNy05YWVmLTRhNDgtODBhYi02NDc2YjQ4MzVjNmUiLCJldmVudF9pZCI6IjBkZGIzMmY4LTRmMTUtNGM2ZC1hM2I1LTliZmUzYTIzMmRjZiIsInRva2VuX3VzZSI6ImFjY2VzcyIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUiLCJhdXRoX3RpbWUiOjE3MTY1ODEyNzIsImV4cCI6MTcxNjU4NDg3MiwiaWF0IjoxNzE2NTgxMjcyLCJqdGkiOiJjNzMxNjE5MC1kNjAzLTQyMGItOTM5Yy0zZTFiNjVlZDU3OGQiLCJ1c2VybmFtZSI6IjI4OTE5M2IwLTEwMDEtNzAxNi00ZDM0LWI2MzFjNjkzZGRhMSJ9.ygyyNnJlDDlY3KKYJu9-yfkI3F2PFVGy44_oIMlWFcPiS7b-IHuDeBpBMlkRhYG_PD4h7HIRp-39UQuuC0gJX4Z3nRIFg49lj4i3h-dsx3gsgNjFPG-MGwWZYJoALK_2PiEqyq4zOl_3Szy5CPRXOXqIwvMKhTtz6l9Saaa-y5zSL_TygF1Y5ZRHiWfGDKIwCdZD5asjuwZa6ZT2FiD-3dARN2OngH7CX9omohcrUPSwyhedFMtKbA4AeCW8y_hhHQFcc_PoI4S80DXBvECzcKvc_GQUPx2fCwGxfE__i57iZVzzhZKrtqXc9Ndoy_ka4T7jVa60DQ_-Jb51rprRVg"
}
"""
    filename = "tmp/getDecodeToken.json"
    createFile(filename, content)
    data = getDecodeToken(filename, "access_token")
    os.remove(filename)

    # print(data)
    # for k, v in data.items():
    #   print(f"'{k}', ", end="")

    # for k, v in data.items():
    #   print(f"{k: >10}: {v}")

    keys = ['sub', 'iss', 'version', 'client_id', 'origin_jti',
            'event_id', 'token_use', 'scope', 'auth_time', 'exp',
            'iat', 'jti', 'username']
    for key in keys:
      if key not in data:
        print(f"missing key: 'key'")
        self.assertTrue(false)

    self.assertEqual(data['scope'], "openid profile")

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
