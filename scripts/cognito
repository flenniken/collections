#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script is for setting up the cognito login system and managing users.

"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap
import random
import string
import botocore

import boto3
from datetime import datetime, timezone
from getpass import getpass

# The name of the application client of a pool created for
# collections.
appName = "CollectionsClient"

class CognitoException(Exception):
  """ An exception we plan for. """
  pass

def convertToKeyValue(cognito_attributes):
  """
  Convert the verbose cognito attributes to a dictionary of key
  value pairs.
  """
# convert:
#
# [
#   {
#     'Name': 'email', 'Value':
#     'steve.flenniken@gmail.com'
#   },
#   {
#     'Name': 'family_name',
#     'Value': 'Flenniken'
#   },
#   {
#     'Name': 'given_name',
#     'Value': 'Steve'
#   },
#   {
#     'Name': 'custom:admin',
#     'Value': '0'
#   }
# ]
#
# to:
#
# {
# 'email': 'steve.flenniken@gmail.com',
# 'family_name': 'Flenniken',
# 'given_name': 'Steve',
# 'custom:admin': 0
# }
  result = {}
  for d in cognito_attributes:
    result[d['Name']] = d['Value']
  return result

def formatDateTime(dt):
  """
  Format a datatime object and return something like: 2024-05-05 21:41:57 UTC
  """
  # https://strftime.org/
  # https://en.wikipedia.org/wiki/ISO_8601
  # return dt.strftime("%Y-%m-%dT%H:%M:%S%z")
  # return dt.astimezone().replace(microsecond=0).isoformat()
  return dt.strftime("%Y-%m-%d %H:%M:%S %Z")

def listUsers(poolName, cognitoClient=None):
  """
  List the users in the given cognito user pool.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()
  pools = poolNamesToIds(cognitoClient)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")

  response = cognitoClient.list_users(
    UserPoolId=pools[poolName],
    AttributesToGet=[ "email", "given_name", "family_name", 'custom:admin']
  )
  users = response['Users']

  # print("id enabled admin status first last email created")

  for user in users:
    a = convertToKeyValue(user['Attributes'])
    print(f"""\

email: {a['email']}
first: {a['given_name']}
last: {a['family_name']}
id: {user['Username']}
status: {user['UserStatus']}
created: {formatDateTime(user['UserCreateDate'])}
admin: {a['custom:admin']}""")


#     # Print a user per line.
#     print(f"\
# {user['Username']} \
# {a['custom:admin']} \
# {user['UserStatus']} \
# {a['given_name']} \
# {a['family_name']} \
# {a['email']} \
# {formatDateTime(user['UserCreateDate'])}")

def createUser(poolName, cognitoClient=None):
  """
  Create a new user in the given cognito user pool.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()
  pools = poolNamesToIds(cognitoClient)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")

  stop = CognitoException("Stopping create user.")

  print("""\
This command will add a new user after prompting for their information.
""")

  email = input("Enter email address, e.g. steve.flenniken@gmail.com\nemail?: ")
  if email == '':
    raise stop
  given_name = input("Enter given name, e.g. Steve\ngiven name?: ")
  if given_name == '':
    raise stop
  family_name = input("Enter family name, e.g. Flenniken\nfamily name?: ")
  if family_name == '':
    raise stop
  admin = inputBoolean("Is the user an admin, True or False?: ")
  if admin is None:
    raise stop
  else:
    admin = 'True' if admin else 'False'
  password = getpass("password?: ")
  if password == '':
    raise stop

  try:
    response = cognitoClient.admin_create_user(
      UserPoolId=pools[poolName],
      Username=email,
      UserAttributes=[
        {
          "Name": "given_name",
           "Value": given_name
        },
        {
          "Name": "family_name",
           "Value": family_name
        },
        {
          "Name": "email",
           "Value": email
        },
        {
          "Name": "email_verified",
          "Value": "true"
        },
        {
          "Name": "custom:admin",
           "Value": admin
        },
      ],
      DesiredDeliveryMediums=['EMAIL'])
  except botocore.exceptions.ClientError as error:
    if error.response['Error']['Code'] == 'UsernameExistsException':
      raise CognitoException("The user already exists.")
    else:
      raise error

  if password != '':
    response = cognitoClient.admin_set_user_password(
        UserPoolId=pools[poolName],
        Username=email,
        Password=password,
        Permanent=True
    )

  # printDict("response", response)

def inputBoolean(message):
  """
  Prompt for a True or False. Return True, False or None.
  """
  result = input(message)
  if result == '':
    return None
  if result != "True" and result != "False":
    raise CognitoException("Invalid True or False setting.")
  if result == "True":
    return True
  return False

def editUser(poolName, userId, cognitoClient=None):
  """
  Edit or delete a user in the given cognito user pool.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()
  pools = poolNamesToIds(cognitoClient)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")

  response = cognitoClient.list_users(
    UserPoolId=pools[poolName],
    AttributesToGet=[ "email", "given_name", "family_name", 'custom:admin']
  )
  users = response['Users']

  for user in users:
    if user['Username'] == userId:
      break;
  else: # no break
    raise CognitoException("The user doesn't exist.")

  print("""\
Type in the new user settings or type enter to leave as is.""")
  a = convertToKeyValue(user['Attributes'])

  email = input(f"{a['email']}, email?: ")
  if email == '':
    email = a['email']

  given_name = input(f"{a['given_name']}, given name?: ")
  if given_name == '':
    given_name = a['given_name']

  family_name = input(f"{a['family_name']}, family name?: ")
  if family_name == '':
    family_name = a['family_name']

  # enabled = inputBoolean(f"{user['Enabled']}, enabled (True or False)?: ")
  # if enabled is None:
  #   enabled = user['Enabled']

  admin = inputBoolean(f"{a['custom:admin']}, admin (True or False)?: ")
  if admin is None:
    admin = a['custom:admin']
  else:
    admin = "True" if admin else "False"
  password = getpass("password?(use blank to leave as is): ")
  if password != '':
    try:
      response = cognitoClient.admin_set_user_password(
          UserPoolId=pools[poolName],
          Username=email,
          Password=password,
          Permanent=True
      )
    except botocore.exceptions.ClientError as error:
      raise CognitoException(error.response['Error']['Message'])

  print(f"""\

email: {email}
first: {given_name}
last: {family_name}
admin: {admin}
""")

  response = cognitoClient.admin_update_user_attributes(
    UserPoolId=pools[poolName],
    Username=email,
    UserAttributes=[
      {
        "Name": "given_name",
         "Value": given_name
      },
      {
        "Name": "family_name",
         "Value": family_name
      },
      {
        "Name": "email",
         "Value": email
      },
      {
        "Name": "custom:admin",
         "Value": admin
      },
    ],
    ClientMetadata={
        'string': 'string'
    }
  )


def getBotoClient(serviceName='cognito-idp'):
  """
  Return the boto3 client for the given AWS service. Services names
  like 'cognito-idp', 'ses', 'sts', etc.
  """
  configFilename = "/home/coder/.aws/config"
  credsFilename = "/home/coder/.aws/credentials"
  if not os.path.exists(configFilename) or not os.path.exists(credsFilename):
     raise CognitoException("""\

Before this script can access your aws cognito user pool, you need an
AWS account and an IAM user with with AmazonCognitoPowerUser and
AmazonSESReadOnlyAccess permissions.

Once the IAM user exists run "aws configure" and specify the IAM
user's credentials.  """)
  return boto3.client(serviceName)

def promptForEmailConfiguration(sesv2Client=None, stsClient=None):
  """
  Show the available emails and let the user pick which one to use.
  Return a dictionary of the email configuration settings.
  """
  if sesv2Client is None:
    sesv2Client = getBotoClient('sesv2')
  if stsClient is None:
    stsClient = getBotoClient('sts')

  noEmailsMsg = """\

There are no available Amazon Simple Email Service (SES) emails to
use. Launch the AWS console and create one for use with the pool.
Make sure to enable and verify it.

"""

  # Get the SES emails.
  response = sesv2Client.list_email_identities()
  email_identities = response.get("EmailIdentities")
  if email_identities is None:
    raise CognitoException(noEmailsMsg)

  # Show the emails and let the user pick the one to use.
  numberOfGood = 0
  possibleEmails = []

  print("""\
Choose the SES email to use when sending mail to users.
0: exit""")

  for email_identity in email_identities:
    response = sesv2Client.get_email_identity(
        EmailIdentity=email_identity['IdentityName']
    )
    if email_identity['IdentityType'] != 'EMAIL_ADDRESS':
      continue
    possibleEmails.append(email_identity)
    name = email_identity['IdentityName']
    if email_identity['SendingEnabled']:
      notEnabled = ""
    else:
      notEnabled = "(not enabled) "
    if email_identity['VerificationStatus'] == "SUCCESS":
      notVerified = ""
    else:
      notVerified = "(not verified) "
    print(f"{len(possibleEmails)}: {name} {notEnabled}{notVerified}")
    if not (notVerified or notEnabled):
      numberOfGood += 1

  if numberOfGood == 0:
    raise CognitoException(noEmailsMsg)

  while True:
    pick = input("Number?: ")
    if pick == '0':
      raise CognitoException("Stopping create pool.")

    try:
      emailNumber = int(pick)
      email_identity = possibleEmails[emailNumber-1]
    except:
      print(f"Invalid email number.")
      continue

    if email_identity['SendingEnabled'] != True:
      print("The email cannot be used because it isn't enabled.")
    elif email_identity['VerificationStatus'] != "SUCCESS":
      print("The email cannot be used because it isn't verified yet.")
    else:
      break # found email

  fromEmail = email_identity['IdentityName']

  msg = f"""\

What friendly name should be used with the email?
Example: Steve Flenniken
Name?: """
  friendlyName = input(msg)
  prettyFromEmail = f"{friendlyName} <{fromEmail}>"

  # Get the AWS account number that we are running under.
  # stsClient = getBotoClient('sts')
  response = stsClient.get_caller_identity()
  accountNumber = response['Account']

  # Get the region where we are going to create the pool.
  region = boto3.Session().region_name

  sourceArn = f"arn:aws:ses:{region}:{accountNumber}:identity/{fromEmail}"

  # todo: get the EmailSendingAccount field from aws ses.
  emailSendingAccount = 'DEVELOPER'

  # Get the AWS account number that we are running under.
  response = stsClient.get_caller_identity()
  accountNumber = response['Account']

  emailConfiguration = {
      'SourceArn': sourceArn,
      'ReplyToEmailAddress': fromEmail,
      'EmailSendingAccount': emailSendingAccount,
      'From': prettyFromEmail,
      # 'ConfigurationSet': 'string'
  }
  return emailConfiguration

def createPool(poolName, cognitoClient=None):
  """
  Create a pool with the given name. Prompt for other parameters when needed.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()

  # Make sure the pool name doesn't already exist.
  pools = poolNamesToIds(cognitoClient)
  if poolName in pools:
    raise CognitoException("The user pool already exists.")

  # Return a dictionary of the email configuration settings needed by
  # the new pool. Look up the SES emails and use the one that is
  # tagged with poolName as this pool's name.
  emailConfiguration = promptForEmailConfiguration()

  yourDomain = input("""\

Enter your domain name where collections is hosted.
Example: collections.flenniken.net
Domain?: """)
  if yourDomain == '':
    raise CognitoException("Stopping create pool.")

  # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp/client/create_user_pool.html

  response = cognitoClient.create_user_pool(
    PoolName = poolName,
    # The defaults are used for the commented out parameters.
    # Policies={
    #     'PasswordPolicy': {
    #         'MinimumLength': 123,
    #         'RequireUppercase': True|False,
    #         'RequireLowercase': True|False,
    #         'RequireNumbers': True|False,
    #         'RequireSymbols': True|False,
    #         'TemporaryPasswordValidityDays': 123
    #     }
    # },
    DeletionProtection='INACTIVE', # ACTIVE | INACTIVE
    # LambdaConfig={
    #     'PreSignUp': 'string',
    #     'CustomMessage': 'string',
    #     'PostConfirmation': 'string',
    #     'PreAuthentication': 'string',
    #     'PostAuthentication': 'string',
    #     'DefineAuthChallenge': 'string',
    #     'CreateAuthChallenge': 'string',
    #     'VerifyAuthChallengeResponse': 'string',
    #     'PreTokenGeneration': 'string',
    #     'UserMigration': 'string',
    #     'PreTokenGenerationConfig': {
    #         'LambdaVersion': 'V1_0'|'V2_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomSMSSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomEmailSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'KMSKeyID': 'string'
    # },
    AutoVerifiedAttributes=['email'],
    # AliasAttributes=['email'],
    UsernameAttributes=['email'],
    # VerificationMessageTemplate={
    #     'SmsMessage': 'string',
    #     'EmailMessage': 'string',
    #     'EmailSubject': 'string',
    #     'EmailMessageByLink': 'string',
    #     'EmailSubjectByLink': 'string',
    #     'DefaultEmailOption': 'CONFIRM_WITH_LINK'|'CONFIRM_WITH_CODE'
    # },
    # SmsAuthenticationMessage='string',
    # MfaConfiguration='OFF',
    # UserAttributeUpdateSettings={
    #     'AttributesRequireVerificationBeforeUpdate': [
    #         'phone_number'|'email',
    #     ]
    # },
    # DeviceConfiguration={
    #     'ChallengeRequiredOnNewDevice': True|False,
    #     'DeviceOnlyRememberedOnUserPrompt': True|False
    # },

    # ses:
    # https://boto3.amazonaws.com/v1/documentation/api/1.26.93/reference/services/ses.html

    EmailConfiguration = emailConfiguration,

    # SmsConfiguration={
    #     'SnsCallerArn': 'string',
    #     'ExternalId': 'string',
    #     'SnsRegion': 'string'
    # },
    # UserPoolTags={
    #     'string': 'string'
    # },
    AdminCreateUserConfig={
        'AllowAdminCreateUserOnly': True,
        # 'UnusedAccountValidityDays': 123,
        # 'InviteMessageTemplate': {
        #     'SMSMessage': 'string',
        #     'EmailMessage': 'string',
        #     'EmailSubject': 'string'
        # }
    },
    # Schema=[
    #     {
    #         'Name': 'string',
    #         'AttributeDataType': 'String'|'Number'|'DateTime'|'Boolean',
    #         'DeveloperOnlyAttribute': True|False,
    #         'Mutable': True|False,
    #         'Required': True|False,
    #         'NumberAttributeConstraints': {
    #             'MinValue': 'string',
    #             'MaxValue': 'string'
    #         },
    #         'StringAttributeConstraints': {
    #             'MinLength': 'string',
    #             'MaxLength': 'string'
    #         }
    #     },
    # ],

    Schema=[
      # {
      #   'Name': 'given_name',
      #   'AttributeDataType': 'String',
      #   'DeveloperOnlyAttribute': False,
      #   'Mutable': True,
      #   'Required': False,
      #   'StringAttributeConstraints': {
      #     'MinLength': '0',
      #     'MaxLength': '2048'
      #   }
      # },
      # {
      #   'Name': 'family_name',
      #   'AttributeDataType': 'String',
      #   'DeveloperOnlyAttribute': False,
      #   'Mutable': True,
      #   'Required': False,
      #   'StringAttributeConstraints': {
      #     'MinLength': '0',
      #     'MaxLength': '2048',
      #   }
      # },
      # {
      #   'Name': 'email',
      #   'AttributeDataType': 'String',
      #   'DeveloperOnlyAttribute': False,
      #   'Mutable': True,
      #   'Required': False,
      #   'StringAttributeConstraints': {
      #     'MinLength': '0',
      #     'MaxLength': '2048',
      #   }
      # },
      # {
      #   'Name': 'email_verified',
      #   'AttributeDataType': 'Boolean',
      #   'DeveloperOnlyAttribute': False,
      #   'Mutable': True,
      #   'Required': False
      # },
      {
        'Name': 'admin', # not custom:admin
        'AttributeDataType': 'Boolean',
        'DeveloperOnlyAttribute': False,
        'Mutable': True,
        'Required': False,
      }
    ],

    # UserPoolAddOns={
    #     'AdvancedSecurityMode': 'OFF'
    # },
    # UsernameConfiguration={
    #     'CaseSensitive': False
    # },

    AccountRecoverySetting={
      'RecoveryMechanisms': [
        {
          'Priority': 1,
          'Name': 'admin_only'
        },
      ]
    }
  )
  # printDict("Response", response)

  userPool = response['UserPool']
  userPoolId = userPool['Id']

  # Create the pool client.
  response = cognitoClient.create_user_pool_client(
    UserPoolId=userPoolId,
    ClientName=appName,
    # GenerateSecret=True|False,
    # RefreshTokenValidity=123,
    # AccessTokenValidity=123,
    # IdTokenValidity=123,
    # TokenValidityUnits={
    #     'AccessToken': 'seconds'|'minutes'|'hours'|'days',
    #     'IdToken': 'seconds'|'minutes'|'hours'|'days',
    #     'RefreshToken': 'seconds'|'minutes'|'hours'|'days'
    # },
    ReadAttributes=[
      "email",
      "family_name",
      "given_name"
    ],
    WriteAttributes=[
      "email",
      "family_name",
      "given_name"
    ],
    ExplicitAuthFlows=[
      'ALLOW_REFRESH_TOKEN_AUTH',
      "ALLOW_USER_PASSWORD_AUTH"
    ],
    SupportedIdentityProviders=[
      "COGNITO"
    ],
    CallbackURLs=[
      f"https://{yourDomain}/index.html"
    ],
    LogoutURLs=[
      f"https://{yourDomain}/index.html"
    ],
    # DefaultRedirectURI='string',
    AllowedOAuthFlows=[
      'code'
    ],
    AllowedOAuthScopes=[
      'aws.cognito.signin.user.admin',
      'email',
      'openid',
      "phone",
      'profile'
    ],
    AllowedOAuthFlowsUserPoolClient=True,
    # AnalyticsConfiguration={
    #     'ApplicationId': 'string',
    #     'ApplicationArn': 'string',
    #     'RoleArn': 'string',
    #     'ExternalId': 'string',
    #     'UserDataShared': True|False
    # },
    PreventUserExistenceErrors='LEGACY',
    EnableTokenRevocation=True,
    EnablePropagateAdditionalUserContextData=False,
    AuthSessionValidity=5
  )

  randomDigits = ''.join(random.choice(string.digits) for x in range(8))
  domainPrefix = f"pool{randomDigits}"

  response = cognitoClient.create_user_pool_domain(
      Domain=domainPrefix,
      UserPoolId=userPoolId,
      # CustomDomainConfig={
      #     'CertificateArn': 'string'
      # }
  )

def printDict(name, d):
  lines = []
  formatDict(name, d, 0, lines)
  print('\n'.join(lines))

def formatDict(name, d, indent=0, lines=[]):
  """
  Format a dictionary recursively and append lines to the lines
  parameter.
  """
  spaces = " " * indent
  spaces2 = spaces + "  "
  if len(d) == 0:
    lines.append(f"{spaces}{name} " + "{}")
  else:
    lines.append(f"{spaces}{name}")
  for k, v in d.items():
    if isinstance(v, datetime):
      value = formatDateTime(v)
    elif isinstance(v, dict):
      ind = indent + 2
      formatDict(k+":", v, ind, lines)
      continue
    elif isinstance(v, list):
      spaces4 = spaces2 + "  "
      lines.append("%s%s: [" % (spaces2, k))
      for item in v:
        if isinstance(item, dict):
          ind = indent + 4
          formatDict("{", item, ind, lines)
          lines.append(spaces4 + "}")
        else:
          lines.append("%s%s" % (spaces4, item))
      lines.append("%s]" % (spaces2))
      continue
    else:
      value = repr(v)
    lines.append("%s%s: %s" % (spaces2, k, value))

def poolNamesToIds(cognitoClient=None):
  """
  Return a dictionary mapping a pool name to a pool userPoolId for all
  the pools.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()

  d = {}
  response = cognitoClient.list_user_pools(MaxResults=30)
  userPools = response.get('UserPools')
  for userPool in userPools:
    userPoolName = userPool["Name"]
    userPoolId = userPool['Id']
    d[userPoolName] = userPoolId
  return d

def writeCognitoConfig(poolName):
  """
  Write the cognito config file: ~/.aws/cognito-config for the
  given the pool name and domain prefix.
  """
  settings = getPoolSettings(poolName)
  config = settings['config']

  # Write the cognito config file: ~/.aws/cognito-config.
  filename = "/home/coder/.aws/cognito-config"
  with open(filename, 'w') as fp:
    fp.write(json.dumps(config))

  print(f"""\
Wrote the cognito config file. View it with:

  cat {filename} | jqless
""")

def showPoolSettings(poolName):
  """
  Show the pool settings.
  """
  settings = getPoolSettings(poolName)
  printDict(poolName + ":", settings)

def printPools():
  """
  Print the cognito pool names.
  """
  # Get the pools.
  pools = poolNamesToIds()
  for name in pools.keys():
    print(name)

def poolAppNameToId(userPoolId, cognitoClient=None):
  """
  Return a dictionary mapping the pool application client names to
  their id.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()

  # Get the pool's application clients.
  response = cognitoClient.list_user_pool_clients(
    UserPoolId=userPoolId,
    MaxResults=30,
  )
  userPoolClients = response.get("UserPoolClients")

  # Build and return a dictionary mapping name to id.
  clients = {}
  for userPoolClient in userPoolClients:
    clientName = userPoolClient['ClientName']
    clientId = userPoolClient['ClientId']
    clients[clientName] = clientId
  return clients

def getPoolSettings(poolName, cognitoClient=None):
  """
  Return the pool setting in a dictionary. The config key contains
  a dictionary for the cognito_config file.
  """
  if cognitoClient is None:
    cognitoClient = getBotoClient()

  # If the pool has more than one application client, prompt for the one to use?

  # Get the pool id of the given pool name.
  pools = poolNamesToIds(cognitoClient)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")
  userPoolId = pools[poolName]

  # Get the user pool settings.
  settings = {}
  response = cognitoClient.describe_user_pool(UserPoolId=userPoolId)
  if 'UserPool' not in response:
    raise CognitoException(f"UserPool was not in the response.")
  settings['UserPool'] = response['UserPool']

  # Find the collections application client.
  poolApps = poolAppNameToId(userPoolId, cognitoClient)
  if appName not in poolApps:
    raise CognitoException(
      f"The pool doesn't have an application client called {appName}.")

  # Get the settings for the collection's application client.
  response = cognitoClient.describe_user_pool_client(
    UserPoolId=userPoolId, ClientId=poolApps[appName])
  userPoolClient = response['UserPoolClient']
  assert userPoolClient['ClientName'] == appName

  # Verify there is one redirect uri.
  callbackURLs = userPoolClient['CallbackURLs']
  if len(callbackURLs) != 1:
    raise CognitoException(f"Expected one redirect_uri but got: {len(callbackURLs)}")
  redirect_uri = callbackURLs[0]

  # Verify there is one callback uri.
  logoutURLs = userPoolClient['LogoutURLs']
  if len(logoutURLs) != 1:
    raise CognitoException(f"Expected one logout_uri but got: {len(logoutURLs)}")
  logout_uri = logoutURLs[0]

  userPool = settings['UserPool']
  if 'Domain' not in userPool:
    raise CognitoException("The user pool does not have a Domain key.")
  domainPrefix = userPool['Domain']

  # Verify there is a domain prefix.
  response = cognitoClient.describe_user_pool_domain(Domain=domainPrefix)
  domainDescription = response['DomainDescription']
  if len(domainDescription) == 0:
    raise CognitoException(f"The domain prefix doesn't exist: {domainPrefix}")

  # Create the cognito domain from the domain prefix and the region
  # extracted from the description.
  region = domainDescription['UserPoolId'].split('_')[0]
  domain = f"https://{domainPrefix}.auth.{region}.amazoncognito.com"

  # Assign the config dictionary and add it to the return settings for
  # use by the congnito-config file.
  config = {}
  config['client_id'] = userPoolClient['ClientId']
  config['redirect_uri'] = redirect_uri
  config['logout_uri'] = logout_uri
  config['scope'] = "openid profile"
  config['domain'] = domain
  settings['config'] = config

  return settings

def process(args):
  """
  """
  if args.listUsers:
    listUsers(args.listUsers)
  elif args.createUser:
    createUser(args.createUser)
  elif args.editUser:
    poolName = args.editUser[0][0]
    userId = args.editUser[0][1]
    editUser(poolName, userId)
  elif args.printPools:
    printPools()
  elif args.showPoolSettings:
    showPoolSettings(args.showPoolSettings)
  elif args.createPool:
    createPool(args.createPool)
  elif args.writeCognitoConfig:
    writeCognitoConfig(args.writeCognitoConfig)
  else:
    raise CognitoException(f"""No implementation for args:
{args}
""")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    # You can run one test by providing the test name as an argument.
    # cognito -t TestCognito.test_poolNamesToIds
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run all or one internal unit tests. You can run just one like this:  cognito -t TestCognito.test_poolNamesToIds")

  parser.add_argument("-p", "--printPools", action='store_true',
    help="print the pool names.")

  parser.add_argument("-s", "--showPoolSettings", metavar="pool-name",
    help="show the pool settings for the given pool.")

  parser.add_argument("-c", "--createPool", metavar="pool-name",
    help="create an AWS Cognito pool with the given name. Use the console to delete it.")

  parser.add_argument("-w", "--writeCognitoConfig", metavar="pool-name",
    help="""write the ~/.aws/cognito-config file containing pool information
needed by the website and login-flow script""")

  parser.add_argument("-l", "--listUsers", metavar='pool-name',
    help="list the pool users.")

  parser.add_argument("-u", "--createUser", metavar='pool-name',
    help="create a new pool user.")

  parser.add_argument("-e", "--editUser", nargs=2, action="append", type=str,
    metavar=("pool-name", "user-id"),
    help="edit an existing pool user. Get the user id from listUsers.")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except CognitoException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success


class TestClients:
  def __init__(self):
    self.cognitoClient = getBotoClient()
    self.sesClient = getBotoClient('ses')
    self.sesv2Client = getBotoClient('sesv2')
    self.stsClient = getBotoClient('sts')

tc = None

def setUpModule():
  # Get the boto clients we test. This method is called once by the
  # test suite. The code is here to avoid a runtime error in the
  # shutdown phase.
  global tc
  tc = TestClients()

def tearDownModule():
  pass

class TestCognito(unittest.TestCase):

  def test_formatDateTime(self):
    dt = datetime(2024, 7, 26, 8, 23, 42, 324562, tzinfo=timezone.utc)
    self.assertEqual(formatDateTime(dt), "2024-07-26 08:23:42 UTC")

  def test_listUsers(self):
    return
    listUsers("collections-pool", tc.cognitoClient)

  def test_poolNamesToIds(self):
    pools = poolNamesToIds(tc.cognitoClient)
    # printDict("pools", pools)

  def test_poolNamesToIds2(self):
    pools = poolNamesToIds(tc.cognitoClient)
    for poolName, poolId in pools.items():
      appClients = poolAppNameToId(poolId, tc.cognitoClient)
      # printDict(f"{poolName} application clients:", appClients)

  def test_convertToKeyValue(self):
    cognito_attributes = [
      {'Name': 'email', 'Value': 'steve.flenniken@gmail.com'},
      {'Name': 'family_name', 'Value': 'Flenniken'},
      {'Name': 'given_name', 'Value': 'Steve'},
      {'Name': 'custom:admin', 'Value': '0'}
    ]
    d = convertToKeyValue(cognito_attributes)
    self.assertEqual(d['email'], 'steve.flenniken@gmail.com')
    self.assertEqual(d['family_name'], 'Flenniken')
    self.assertEqual(d['given_name'], 'Steve')
    self.assertEqual(d['custom:admin'], '0')

  def test_formatDict1(self):
    d = {
      "a": 5,
      "b": "hello",
    }
    lines = []
    formatDict("name:", d, 0, lines)
    formatDict("name2:", d, 0, lines)
    # print("\n".join(lines))
    # print("----end----")
    got = '\n'.join(lines)
    expected = """\
name:
  a: 5
  b: 'hello'
name2:
  a: 5
  b: 'hello'"""
    self.assertEqual(got, expected)

  def test_formatDict2(self):
    dt = datetime(2024, 6, 2, 4, 4, 42, 501295, tzinfo=timezone.utc)
    d = {
      "a": 5,
      "b": "hello",
      "date": dt,
      "list": [1, 2, 3, 4],
      "nested": {"n1": "asdf", "n2": "adsfasdf"},
      "list": [1, {"x":1, "y":2}, 3, 4, "hi"],
      "anotherdict": {"c": 5, "d": {}, "e": 42},
    }
    # print(d)
    lines = []
    formatDict("name:", d, 0, lines)
    got = '\n'.join(lines)

    expected = """\
name:
  a: 5
  b: 'hello'
  date: 2024-06-02 04:04:42 UTC
  list: [
    1
    {
      x: 1
      y: 2
    }
    3
    4
    hi
  ]
  nested:
    n1: 'asdf'
    n2: 'adsfasdf'
  anotherdict:
    c: 5
    d: {}
    e: 42"""
    self.assertEqual(got, expected)

  def test_list_identities(self):
    # Returns a list containing all of the identities (email addresses
    # and domains) for your AWS account in the current AWS Region,
    # regardless of verification status.
    response = tc.sesClient.list_identities(MaxItems=30)
    # print()
    # printDict("list_identities", response)
    self.assertTrue('Identities' in response)
    return

  def test_getAccountNumber(self):
    response = tc.stsClient.get_caller_identity()
    # printDict("get_caller_identity", response)
    self.assertTrue('Account' in response)

  def test_promptForEmailConfiguration(self):
    return
    print("\n")
    emailConfiguration = promptForEmailConfiguration(tc.sesv2Client, tc.stsClient)
    print("")
    printDict("EmailConfiguration", emailConfiguration)

  def test_list_email_identities(self):
    response = tc.sesv2Client.list_email_identities()
    # printDict("list_email_identities", response)

  def test_get_email_identity(self):
    return
    response = tc.sesv2Client.get_email_identity(
        EmailIdentity='collections@flenniken.net'
    )
    printDict("get_email_identity", response)

  def test_getPoolSettings(self):
    return
    settings = getPoolSettings("collections-pool", tc.cognitoClient)
    # printDict("pool settings", settings)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
