#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script is for setting up the cognito login system and managing users.

"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap
import tomllib
import boto3
from datetime import datetime, timezone

class CognitoException(Exception):
  """ An exception we plan for. """
  pass

def getAttributes(cognito_attributes):
  """
  Convert the cognito attributes to a dictionary.
  """
# 'Attributes': [{'Name': 'email', 'Value':
#   'steve.flenniken@gmail.com'}, {'Name': 'family_name', 'Value':
#   'Flenniken'}, {'Name': 'given_name', 'Value': 'Steve'}, {'Name':
#   'custom:admin', 'Value': '0'}]
#
# { 'email': 'steve.flenniken@gmail.com', 'family_name': 'Flenniken', 'given_name': 'Steve', 'custom:admin': 0}
  result = {}
  for d in cognito_attributes:
    result[d['Name']] = d['Value']
  return result

def formatDateTime(dt):
  """
  Format a datatime object and return something like: 2024-05-05 21:41:57 UTC
  """
  # https://strftime.org/
  # https://en.wikipedia.org/wiki/ISO_8601
  # return dt.strftime("%Y-%m-%dT%H:%M:%S%z")
  # return dt.astimezone().replace(microsecond=0).isoformat()
  return dt.strftime("%Y-%m-%d %H:%M:%S %Z")

def listUsers(poolName):
  """
  Show the users.
  """
  client = getCognitoBoto3Client()
  userPoolId = getUserPoolId(client, poolName)
  response = client.list_users(
    UserPoolId=userPoolId,
    AttributesToGet=[ "email", "given_name", "family_name", 'custom:admin']
  )
  users = response['Users']

  print("id enabled admin status first last email created")
  for user in users:
    a = getAttributes(user['Attributes'])
    # print(f"email: {a['email']}")
    # print(f"given_name: {a['given_name']}")
    # print(f"family_name: {a['family_name']}")
    # print(f"custom:admin: {a['custom:admin']}")
    # print(f"Username: {user['Username']}")
    # print(f"UserCreateDate: {formatDateTime(user['UserCreateDate'])}")
    # print(f"UserLastModifiedDate: {formatDateTime(user['UserLastModifiedDate'])}")
    # print(f"Enabled: {user['Enabled']}")
    # print(f"Enabled: {user['UserStatus']}")

    # Print a user per line.
    print(f"\
{user['Username']} \
{user['Enabled']} \
{a['custom:admin']} \
{user['UserStatus']} \
{a['given_name']} \
{a['family_name']} \
{a['email']} \
{formatDateTime(user['UserCreateDate'])}")

def getCognitoBoto3Client():
  """
  Return the boto3 cognito client.
  """
  configFilename = "/home/coder/.aws/config"
  credsFilename = "/home/coder/.aws/credentials"
  if not os.path.exists(configFilename) or not os.path.exists(credsFilename):
     raise CognitoException("""\

Before this script can access your aws cognito user pool, you need an
AWS account and an IAM user with with AmazonCognitoPowerUser
permissions.

Run "aws configure" and specify the IAM user's credentials.
""")
  return boto3.client('cognito-idp')

def createPool(poolName, domainPrefix):
  """
  Create the pool. Example poolName: collections-pool, example
  domainPrefix: collections. The domainPrefix must be unique in the
  world.
  """
  client = getCognitoBoto3Client()

  # reference:
  # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp/client/create_user_pool.html

  response = client.create_user_pool(
    PoolName = poolName,
    # Use defaults for the commented out parameters.
    # Policies={
    #     'PasswordPolicy': {
    #         'MinimumLength': 123,
    #         'RequireUppercase': True|False,
    #         'RequireLowercase': True|False,
    #         'RequireNumbers': True|False,
    #         'RequireSymbols': True|False,
    #         'TemporaryPasswordValidityDays': 123
    #     }
    # },
    DeletionProtection='ACTIVE',
    # LambdaConfig={
    #     'PreSignUp': 'string',
    #     'CustomMessage': 'string',
    #     'PostConfirmation': 'string',
    #     'PreAuthentication': 'string',
    #     'PostAuthentication': 'string',
    #     'DefineAuthChallenge': 'string',
    #     'CreateAuthChallenge': 'string',
    #     'VerifyAuthChallengeResponse': 'string',
    #     'PreTokenGeneration': 'string',
    #     'UserMigration': 'string',
    #     'PreTokenGenerationConfig': {
    #         'LambdaVersion': 'V1_0'|'V2_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomSMSSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomEmailSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'KMSKeyID': 'string'
    # },
    AutoVerifiedAttributes=['email'],
    # AliasAttributes=['email'],
    UsernameAttributes=['email'],
    # VerificationMessageTemplate={
    #     'SmsMessage': 'string',
    #     'EmailMessage': 'string',
    #     'EmailSubject': 'string',
    #     'EmailMessageByLink': 'string',
    #     'EmailSubjectByLink': 'string',
    #     'DefaultEmailOption': 'CONFIRM_WITH_LINK'|'CONFIRM_WITH_CODE'
    # },
    # SmsAuthenticationMessage='string',
    # MfaConfiguration='OFF',
    # UserAttributeUpdateSettings={
    #     'AttributesRequireVerificationBeforeUpdate': [
    #         'phone_number'|'email',
    #     ]
    # },
    # DeviceConfiguration={
    #     'ChallengeRequiredOnNewDevice': True|False,
    #     'DeviceOnlyRememberedOnUserPrompt': True|False
    # },

    # todo: pass in the following?
    EmailConfiguration={
        'SourceArn': 'arn:aws:ses:us-west-2:169317056116:identity/collections@flenniken.net',
        'ReplyToEmailAddress': 'collections@flenniken.net',
        'EmailSendingAccount': 'DEVELOPER',
        'From': 'Steve Flenniken <collections@flenniken.net>',
        # 'ConfigurationSet': 'string'
    },
    # SmsConfiguration={
    #     'SnsCallerArn': 'string',
    #     'ExternalId': 'string',
    #     'SnsRegion': 'string'
    # },
    # UserPoolTags={
    #     'string': 'string'
    # },
    AdminCreateUserConfig={
        'AllowAdminCreateUserOnly': True,
        # 'UnusedAccountValidityDays': 123,
        # 'InviteMessageTemplate': {
        #     'SMSMessage': 'string',
        #     'EmailMessage': 'string',
        #     'EmailSubject': 'string'
        # }
    },
    # Schema=[
    #     {
    #         'Name': 'string',
    #         'AttributeDataType': 'String'|'Number'|'DateTime'|'Boolean',
    #         'DeveloperOnlyAttribute': True|False,
    #         'Mutable': True|False,
    #         'Required': True|False,
    #         'NumberAttributeConstraints': {
    #             'MinValue': 'string',
    #             'MaxValue': 'string'
    #         },
    #         'StringAttributeConstraints': {
    #             'MinLength': 'string',
    #             'MaxLength': 'string'
    #         }
    #     },
    # ],
    # UserPoolAddOns={
    #     'AdvancedSecurityMode': 'OFF'
    # },
    # UsernameConfiguration={
    #     'CaseSensitive': False
    # },
    # AccountRecoverySetting={
    #     'RecoveryMechanisms': [
    #         {
    #             'Priority': 123,
    #             'Name': 'verified_email'|'verified_phone_number'|'admin_only'
    #         },
    #     ]
    # }
  )
  print(response)
  printDict("Response", response)

def printDict(name, d):
  lines = []
  formatDict(name, d, 0, lines)
  print('\n'.join(lines))

def formatDict(name, d, indent=0, lines=[]):
  """
  Format a dictionary recursively and append lines to the lines
  parameter.
  """
  spaces = " " * indent
  spaces2 = spaces + "  "
  if len(d) == 0:
    lines.append(f"{spaces}{name} " + "{}")
  else:
    lines.append(f"{spaces}{name}")
  for k, v in d.items():
    if isinstance(v, datetime):
      value = formatDateTime(v)
    elif isinstance(v, dict):
      ind = indent + 2
      formatDict(k+":", v, ind, lines)
      continue
    elif isinstance(v, list):
      spaces4 = spaces2 + "  "
      lines.append("%s%s: [" % (spaces2, k))
      for item in v:
        if isinstance(item, dict):
          ind = indent + 4
          formatDict("{", item, ind, lines)
          lines.append(spaces4 + "}")
        else:
          lines.append("%s%s" % (spaces4, item))
      lines.append("%s]" % (spaces2))
      continue
    else:
      value = repr(v)
    lines.append("%s%s: %s" % (spaces2, k, value))

def getUserPoolId(client, poolName, lines=None):
  """
  Return the userPoolId for the given pool name. When lines is not
  None, append the pool details to lines.
  """
  # Get the cognito user pools.
  response = client.list_user_pools(MaxResults=30)
  userPools = response['UserPools']

  # Find the pool name.
  userPoolId = None
  if lines is not None:
    lines.append("User Pools:")
  for ix, userPool in enumerate(userPools):
    name = userPool['Name']
    id = userPool['Id']
    if lines is not None:
      lines.append(f"  {ix+1} {name} {id}")
    if name == poolName:
      userPoolId = id
  if lines is not None:
    lines.append("")

  if userPoolId is None:
    # The specified pool was not found.
    raise CognitoException(f"The pool name doesn't exist: {poolName}")
  return userPoolId

def writeCognitoConfig(poolName, domainPrefix):
  """
  Write the cognito config file: ~/.aws/cognito-config for the
  given the pool name and domain prefix.
  """
  config = getPoolSettings(poolName, domainPrefix, lines=None)

  # Write the cognito config file: ~/.aws/cognito-config.
  filename = "/home/coder/.aws/cognito-config"
  with open(filename, 'w') as fp:
    fp.write(json.dumps(config))

  print(f"""\
Wrote the cognito config file. View it with:

  cat {filename} | jqless
""")

def listPoolSettings(poolName, domainPrefix):
  lines = []
  config = None
  error = ""
  try:
    config = getPoolSettings(poolName, domainPrefix, lines)
  except CognitoException as ex:
    error = str(ex)
  print('\n'.join(lines))
  if config:
    printDict("Config", config)
  if error:
    print(error)

def getPoolSettings(poolName, domainPrefix, lines=None):
  """
  Append the pool setting lines to the lines parameter (when not
  None) and return the config settings as a dictionary.
  """
  client = getCognitoBoto3Client()
  userPoolId = getUserPoolId(client, poolName, lines=lines)

  # Get the user pool settings.
  response = client.describe_user_pool(UserPoolId=userPoolId)
  if 'UserPool' not in response:
    raise CognitoException(f"  UserPool was not in the response.")
  if lines:
    formatDict(poolName+":", response['UserPool'], 0, lines)

  # Get the pool's application clients.
  response = client.list_user_pool_clients(
    UserPoolId=userPoolId,
    MaxResults=30,
  )

  # Find the collections client.
  collectionsClientName = "CollectionsClient"
  client_id = None
  if lines:
    lines.append("Application clients:")
  userPoolClients = response["UserPoolClients"]
  for ix, userPoolClient in enumerate(userPoolClients):
    name = userPoolClient['ClientName']
    id = userPoolClient['ClientId']
    if lines:
      lines.append(f"  {ix+1} {name} {id}")
    if name == collectionsClientName:
      client_id = id
  if lines:
    lines.append('')
  if client_id is None:
    raise CognitoException(
      f"The pool doesn't have an application client called {collectionsClientName}.")

  response = client.describe_user_pool_client(
    UserPoolId=userPoolId, ClientId=client_id)

  userPoolClient = response['UserPoolClient']
  assert userPoolClient['ClientName'] == 'CollectionsClient'
  if lines:
    formatDict(collectionsClientName+":", userPoolClient, 0, lines)

  callbackURLs = userPoolClient['CallbackURLs']
  if len(callbackURLs) != 1:
    raise CognitoException(f"Expected one callback (redirect_uri) but got: {len(callbackURLs)}")
  redirect_uri = callbackURLs[0]

  logoutURLs = userPoolClient['LogoutURLs']
  if len(logoutURLs) != 1:
    raise CognitoException(f"Expected one callback (logout_uri) but got: {len(logoutURLs)}")
  logout_uri = logoutURLs[0]

  # Is it possible to query cognito for the domain prefix? Then
  # we wouldn't need to pass it in.

  response = client.describe_user_pool_domain(Domain=domainPrefix)
  domainDescription = response['DomainDescription']
  if len(domainDescription) == 0:
    raise CognitoException(f"  The domain prefix doesn't exist: {domainPrefix}")
  if lines:
    formatDict("DomainDescription:", domainDescription, 0, lines)

  ## cognito domain

  # UserPoolId: 'us-west-2_Lm2lu6ocX'
  region = domainDescription['UserPoolId'].split('_')[0]
  domain = f"https://{domainPrefix}.auth.{region}.amazoncognito.com"
  if lines:
    lines.append('')
    lines.append(f"domain: {domain}")
    lines.append('')

  # Hard code the scope.
  scope = "openid profile"

  config = {}
  config['client_id'] = client_id
  config['redirect_uri'] = redirect_uri
  config['logout_uri'] = logout_uri
  config['scope'] = scope
  config['domain'] = domain
  return config

def process(args):
  """
  """
  if args.listUsers:
    listUsers(args.listUsers)
  elif args.listPoolSettings:
    poolName = args.listPoolSettings[0][0]
    domainPrefix = args.listPoolSettings[0][1]
    listPoolSettings(poolName, domainPrefix)
  elif args.createPool:
    poolName = args.createPool[0][0]
    domainPrefix = args.createPool[0][1]
    createPool(poolName, domainPrefix)
  elif args.writeCognitoConfig:
    poolName = args.writeCognitoConfig[0][0]
    domainPrefix = args.writeCognitoConfig[0][1]
    writeCognitoConfig(poolName, domainPrefix)
  else:
    raise CognitoException(f"""No implementation for args:
{args}
""")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")

  parser.add_argument("-c", "--createPool", nargs=2, action="append", type=str,
    metavar=("pool-name", "domainPrefix"),
    help="create a cognito pool with the given name and domain prefix. The domainPrefix needs to be unique. Example: [scripts/cognito -c collections-pool collections]")

  parser.add_argument("-w", "--writeCognitoConfig", nargs=2, action="append", type=str,
    metavar=("pool-name", "domainPrefix"),
    help="write the ~/.aws/cognito-config file. Example: [scripts/cognito -w collections-pool collections]")

  parser.add_argument("-s", "--listPoolSettings", nargs=2, action="append", type=str,
    metavar=("pool-name", "domainPrefix"),
    help="list the pool settings for the given cognito pool. Example: [scripts/cognito -s collections-pool collections]")

  parser.add_argument("-l", "--listUsers", metavar='pool-name',
    help="show the pool users for the given cognito pool")
  parser.add_argument("-u", "--createUser", action="store_true",
    help="Not Implemented: create a new user")
  parser.add_argument("-e", "--editUser", metavar='user-id',
    help="Not Implemented: edit an existing user")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except CognitoException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

class TestCognito(unittest.TestCase):

  def test_me(self):
    self.assertEqual(True, bool(1))
    self.assertEqual(False, bool(0))

  def test_getAttributes(self):
    cognito_attributes = [
      {'Name': 'email', 'Value': 'steve.flenniken@gmail.com'},
      {'Name': 'family_name', 'Value': 'Flenniken'},
      {'Name': 'given_name', 'Value': 'Steve'},
      {'Name': 'custom:admin', 'Value': '0'}
    ]
    d = getAttributes(cognito_attributes)
    self.assertEqual(d['email'], 'steve.flenniken@gmail.com')
    self.assertEqual(d['family_name'], 'Flenniken')
    self.assertEqual(d['given_name'], 'Steve')
    self.assertEqual(d['custom:admin'], '0')

  def test_formatDict1(self):
    d = {
      "a": 5,
      "b": "hello",
    }
    lines = []
    formatDict("name:", d, 0, lines)
    formatDict("name2:", d, 0, lines)
    # print("\n".join(lines))
    # print("----end----")
    got = '\n'.join(lines)
    expected = """\
name:
  a: 5
  b: 'hello'
name2:
  a: 5
  b: 'hello'"""
    self.assertEqual(got, expected)

  def test_formatDict(self):
    dt = datetime(2024, 6, 2, 4, 4, 42, 501295, tzinfo=timezone.utc)
    d = {
      "a": 5,
      "b": "hello",
      "date": dt,
      "list": [1, 2, 3, 4],
      "nested": {"n1": "asdf", "n2": "adsfasdf"},
      "list": [1, {"x":1, "y":2}, 3, 4, "hi"],
      "anotherdict": {"c": 5, "d": {}, "e": 42},
    }
    # print(d)
    lines = []
    formatDict("name:", d, 0, lines)
    got = '\n'.join(lines)

    expected = """\
name:
  a: 5
  b: 'hello'
  date: 2024-06-02 04:04:42 UTC
  list: [
    1
    {
      x: 1
      y: 2
    }
    3
    4
    hi
  ]
  nested:
    n1: 'asdf'
    n2: 'adsfasdf'
  anotherdict:
    c: 5
    d: {}
    e: 42"""
    self.assertEqual(got, expected)

  # def test_getUserPoolId(self):
  #   client = getCognitoBoto3Client()
  #   userPoolId = getUserPoolId(client, "collections-pool", lines=None)
  #   self.assertEqual(userPoolId, "us-west-2_Lm2lu6ocX")

  # def test_getUserPoolId_lines(self):
  #   client = getCognitoBoto3Client()
  #   lines = []
  #   userPoolId = getUserPoolId(client, "collections-pool", lines=lines)
  #   for line in lines:
  #     print(line)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
