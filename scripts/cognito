#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script is for setting up the cognito login system and managing users.

"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap
import tomllib
import boto3
from datetime import datetime, timezone

clientName = "CollectionsClient"


class CognitoException(Exception):
  """ An exception we plan for. """
  pass

def getAttributes(cognito_attributes):
  """
  Convert the cognito attributes to a dictionary.
  """
# 'Attributes': [{'Name': 'email', 'Value':
#   'steve.flenniken@gmail.com'}, {'Name': 'family_name', 'Value':
#   'Flenniken'}, {'Name': 'given_name', 'Value': 'Steve'}, {'Name':
#   'custom:admin', 'Value': '0'}]
#
# { 'email': 'steve.flenniken@gmail.com', 'family_name': 'Flenniken', 'given_name': 'Steve', 'custom:admin': 0}
  result = {}
  for d in cognito_attributes:
    result[d['Name']] = d['Value']
  return result

def formatDateTime(dt):
  """
  Format a datatime object and return something like: 2024-05-05 21:41:57 UTC
  """
  # https://strftime.org/
  # https://en.wikipedia.org/wiki/ISO_8601
  # return dt.strftime("%Y-%m-%dT%H:%M:%S%z")
  # return dt.astimezone().replace(microsecond=0).isoformat()
  return dt.strftime("%Y-%m-%d %H:%M:%S %Z")

def listUsers(poolName):
  """
  List the users.
  """
  client = getCognitoBoto3Client()
  pools = poolNameToId(client)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")

  response = client.list_users(
    UserPoolId=pool[poolName],
    AttributesToGet=[ "email", "given_name", "family_name", 'custom:admin']
  )
  users = response['Users']

  print("id enabled admin status first last email created")
  for user in users:
    a = getAttributes(user['Attributes'])
    # print(f"email: {a['email']}")
    # print(f"given_name: {a['given_name']}")
    # print(f"family_name: {a['family_name']}")
    # print(f"custom:admin: {a['custom:admin']}")
    # print(f"Username: {user['Username']}")
    # print(f"UserCreateDate: {formatDateTime(user['UserCreateDate'])}")
    # print(f"UserLastModifiedDate: {formatDateTime(user['UserLastModifiedDate'])}")
    # print(f"Enabled: {user['Enabled']}")
    # print(f"Enabled: {user['UserStatus']}")

    # Print a user per line.
    print(f"\
{user['Username']} \
{user['Enabled']} \
{a['custom:admin']} \
{user['UserStatus']} \
{a['given_name']} \
{a['family_name']} \
{a['email']} \
{formatDateTime(user['UserCreateDate'])}")

def getCognitoBoto3Client():
  """
  Return the boto3 cognito client.
  """
  configFilename = "/home/coder/.aws/config"
  credsFilename = "/home/coder/.aws/credentials"
  if not os.path.exists(configFilename) or not os.path.exists(credsFilename):
     raise CognitoException("""\

Before this script can access your aws cognito user pool, you need an
AWS account and an IAM user with with AmazonCognitoPowerUser
permissions.

Run "aws configure" and specify the IAM user's credentials.
""")
  return boto3.client('cognito-idp')

def createPool(poolName):
  """
  Create a pool with the given name. Prompt for other parameters when needed.
  """
  client = getCognitoBoto3Client()

  # Make sure the pool name doesn't already exist.
  pools = poolNameToId(client)
  if poolName in pools:
    raise CognitoException("The user pool already exists.")

  # reference:
  # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp/client/create_user_pool.html

  response = client.create_user_pool(
    PoolName = poolName,
    # Use defaults for the commented out parameters.
    # Policies={
    #     'PasswordPolicy': {
    #         'MinimumLength': 123,
    #         'RequireUppercase': True|False,
    #         'RequireLowercase': True|False,
    #         'RequireNumbers': True|False,
    #         'RequireSymbols': True|False,
    #         'TemporaryPasswordValidityDays': 123
    #     }
    # },
    DeletionProtection='ACTIVE',
    # LambdaConfig={
    #     'PreSignUp': 'string',
    #     'CustomMessage': 'string',
    #     'PostConfirmation': 'string',
    #     'PreAuthentication': 'string',
    #     'PostAuthentication': 'string',
    #     'DefineAuthChallenge': 'string',
    #     'CreateAuthChallenge': 'string',
    #     'VerifyAuthChallengeResponse': 'string',
    #     'PreTokenGeneration': 'string',
    #     'UserMigration': 'string',
    #     'PreTokenGenerationConfig': {
    #         'LambdaVersion': 'V1_0'|'V2_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomSMSSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomEmailSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'KMSKeyID': 'string'
    # },
    AutoVerifiedAttributes=['email'],
    # AliasAttributes=['email'],
    UsernameAttributes=['email'],
    # VerificationMessageTemplate={
    #     'SmsMessage': 'string',
    #     'EmailMessage': 'string',
    #     'EmailSubject': 'string',
    #     'EmailMessageByLink': 'string',
    #     'EmailSubjectByLink': 'string',
    #     'DefaultEmailOption': 'CONFIRM_WITH_LINK'|'CONFIRM_WITH_CODE'
    # },
    # SmsAuthenticationMessage='string',
    # MfaConfiguration='OFF',
    # UserAttributeUpdateSettings={
    #     'AttributesRequireVerificationBeforeUpdate': [
    #         'phone_number'|'email',
    #     ]
    # },
    # DeviceConfiguration={
    #     'ChallengeRequiredOnNewDevice': True|False,
    #     'DeviceOnlyRememberedOnUserPrompt': True|False
    # },

    # todo: pass in the following. The email needs to be setup in
    # Amazon ahead of time.  Here we query for the information and put
    # it in the pool settings. Create a command to setup the email.
    # ses:
    # https://us-west-2.console.aws.amazon.com/ses/home?region=us-west-2#/identities

    EmailConfiguration={
        'SourceArn': 'arn:aws:ses:us-west-2:169317056116:identity/collections@flenniken.net',
        'ReplyToEmailAddress': 'collections@flenniken.net',
        'EmailSendingAccount': 'DEVELOPER',
        'From': 'Steve Flenniken <collections@flenniken.net>',
        # 'ConfigurationSet': 'string'
    },
    # SmsConfiguration={
    #     'SnsCallerArn': 'string',
    #     'ExternalId': 'string',
    #     'SnsRegion': 'string'
    # },
    # UserPoolTags={
    #     'string': 'string'
    # },
    AdminCreateUserConfig={
        'AllowAdminCreateUserOnly': True,
        # 'UnusedAccountValidityDays': 123,
        # 'InviteMessageTemplate': {
        #     'SMSMessage': 'string',
        #     'EmailMessage': 'string',
        #     'EmailSubject': 'string'
        # }
    },
    # Schema=[
    #     {
    #         'Name': 'string',
    #         'AttributeDataType': 'String'|'Number'|'DateTime'|'Boolean',
    #         'DeveloperOnlyAttribute': True|False,
    #         'Mutable': True|False,
    #         'Required': True|False,
    #         'NumberAttributeConstraints': {
    #             'MinValue': 'string',
    #             'MaxValue': 'string'
    #         },
    #         'StringAttributeConstraints': {
    #             'MinLength': 'string',
    #             'MaxLength': 'string'
    #         }
    #     },
    # ],
    # UserPoolAddOns={
    #     'AdvancedSecurityMode': 'OFF'
    # },
    # UsernameConfiguration={
    #     'CaseSensitive': False
    # },
    # AccountRecoverySetting={
    #     'RecoveryMechanisms': [
    #         {
    #             'Priority': 123,
    #             'Name': 'verified_email'|'verified_phone_number'|'admin_only'
    #         },
    #     ]
    # }
  )
  print(response)
  printDict("Response", response)

  # Create the pool client.
  response = client.create_user_pool_client(
    UserPoolId=userPoolId,
    ClientName=clientName,
    # GenerateSecret=True|False,
    # RefreshTokenValidity=123,
    # AccessTokenValidity=123,
    # IdTokenValidity=123,
    # TokenValidityUnits={
    #     'AccessToken': 'seconds'|'minutes'|'hours'|'days',
    #     'IdToken': 'seconds'|'minutes'|'hours'|'days',
    #     'RefreshToken': 'seconds'|'minutes'|'hours'|'days'
    # },
    ReadAttributes=[
      "email",
      "family_name",
      "given_name"
    ],
    WriteAttributes=[
      "email",
      "family_name",
      "given_name"
    ],
    ExplicitAuthFlows=[
      'ALLOW_REFRESH_TOKEN_AUTH',
      "ALLOW_USER_PASSWORD_AUTH"
    ],
    SupportedIdentityProviders=[
      "COGNITO"
    ],
    CallbackURLs=[
      "https://collections.flenniken.net/index.html"
    ],
    LogoutURLs=[
      'https://collections.flenniken.net/index.html'
    ],
    # DefaultRedirectURI='string',
    AllowedOAuthFlows=[
      'code'
    ],
    AllowedOAuthScopes=[
      'aws.cognito.signin.user.admin',
      'email',
      'openid',
      "phone",
      'profile'
    ],
    AllowedOAuthFlowsUserPoolClient=True,
    # AnalyticsConfiguration={
    #     'ApplicationId': 'string',
    #     'ApplicationArn': 'string',
    #     'RoleArn': 'string',
    #     'ExternalId': 'string',
    #     'UserDataShared': True|False
    # },
    PreventUserExistenceErrors='LEGACY',
    EnableTokenRevocation=True,
    EnablePropagateAdditionalUserContextData=False,
    AuthSessionValidity=5
  )

  msg = """\
The domainPrefix is used in the login and logout urls
with Amazon. It is a short string of lower case letters, digits,
underscores and hyphens. It must be unique with Amazon.

For example, "collections" is a domain prefix and it is used like:

https://collections.auth.us-west-2.amazoncognito.com

domain prefix: """

  domainPrefix = input(msg)
  response = client.create_user_pool_domain(
      Domain=domainPrefix,
      UserPoolId=userPoolId,
      # CustomDomainConfig={
      #     'CertificateArn': 'string'
      # }
  )

def printDict(name, d):
  lines = []
  formatDict(name, d, 0, lines)
  print('\n'.join(lines))

def formatDict(name, d, indent=0, lines=[]):
  """
  Format a dictionary recursively and append lines to the lines
  parameter.
  """
  spaces = " " * indent
  spaces2 = spaces + "  "
  if len(d) == 0:
    lines.append(f"{spaces}{name} " + "{}")
  else:
    lines.append(f"{spaces}{name}")
  for k, v in d.items():
    if isinstance(v, datetime):
      value = formatDateTime(v)
    elif isinstance(v, dict):
      ind = indent + 2
      formatDict(k+":", v, ind, lines)
      continue
    elif isinstance(v, list):
      spaces4 = spaces2 + "  "
      lines.append("%s%s: [" % (spaces2, k))
      for item in v:
        if isinstance(item, dict):
          ind = indent + 4
          formatDict("{", item, ind, lines)
          lines.append(spaces4 + "}")
        else:
          lines.append("%s%s" % (spaces4, item))
      lines.append("%s]" % (spaces2))
      continue
    else:
      value = repr(v)
    lines.append("%s%s: %s" % (spaces2, k, value))

def poolNameToId(client):
  """
  Return a dictionary mapping pool name to pool userPoolId.
  """
  d = {}
  response = client.list_user_pools(MaxResults=30)
  userPools = response.get('UserPools')
  for userPool in userPools:
    userPoolName = userPool["Name"]
    userPoolId = userPool['Id']
    d[userPoolName] = userPoolId
  return d

def writeCognitoConfig(poolName, domainPrefix):
  """
  Write the cognito config file: ~/.aws/cognito-config for the
  given the pool name and domain prefix.
  """
  settings = getPoolSettings(poolName)
  config = settings['config']

  # Write the cognito config file: ~/.aws/cognito-config.
  filename = "/home/coder/.aws/cognito-config"
  with open(filename, 'w') as fp:
    fp.write(json.dumps(config))

  print(f"""\
Wrote the cognito config file. View it with:

  cat {filename} | jqless
""")

def showPoolSettings(poolName):
  """
  Show the pool settings.
  """
  settings = getPoolSettings(poolName)
  printDict(poolName + ":", settings)

def printPools():
  """
  """
  # Get the pools.
  client = getCognitoBoto3Client()
  pools = poolNameToId(client)
  for name in pools.keys():
    print(name)

  # client = getCognitoBoto3Client()
  # response = client.list_user_pools(MaxResults=30)
  # userPools = response['UserPools']

  # for userPoolsBasic in userPools:
  #   name = userPoolsBasic['Name']
  #   userPoolId = userPoolsBasic['Id']
  #   print(f"  {name} {domainPrefix} '{clientName}'")

  #   # Get the user pool information and pull out the domain prefix.
  #   response = client.describe_user_pool(UserPoolId=userPoolId)
  #   if 'UserPool' not in response:
  #     raise CognitoException(f"UserPool was not in the response.")
  #   userPool = response['UserPool']
  #   domainPrefix = userPool['Domain']

  #   # Get the pool's application clients.
  #   response = client.list_user_pool_clients(
  #       UserPoolId=userPoolId,
  #       MaxResults=30,
  #   )

  #   userPoolClients = response["UserPoolClients"]
  #   for userPoolClient in userPoolClients:
  #     clientName = userPoolClient['ClientName']
  #     clientId = userPoolClient['ClientId']
  #     print(f"  {name} {domainPrefix} '{clientName}'")

def poolClientNameToId(client, userPoolId):
  """
  Return a dictionary mapping the pool client names to their id.
  """

  # Get the pool's application clients.
  response = client.list_user_pool_clients(
    UserPoolId=userPoolId,
    MaxResults=30,
  )
  userPoolClients = response.get("UserPoolClients")

  # Build and return a dictionary mapping name to id.
  clients = {}
  for userPoolClient in userPoolClients:
    clientName = userPoolClient['ClientName']
    clientId = userPoolClient['ClientId']
    clients[clientName] = clientId
  return clients

def getPoolSettings(poolName):
  """
  Return the pool setting in a dictionary. The config key contains
  a dictionary for the cognito_config file.
  """
  # If the pool has more than one application client, prompt for the one to use?

  # Get the pool id of the given pool name.
  client = getCognitoBoto3Client()
  pools = poolNameToId(client)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")
  userPoolId = pools[poolName]

  # Get the user pool settings.
  settings = {}
  response = client.describe_user_pool(UserPoolId=userPoolId)
  if 'UserPool' not in response:
    raise CognitoException(f"UserPool was not in the response.")
  settings['UserPool'] = response['UserPool']

  # Find the collections client.
  clients = poolClientNameToId(client, userPoolId)
  if clientName not in clients:
    raise CognitoException(
      f"The pool doesn't have an application client called {clientName}.")

  response = client.describe_user_pool_client(
    UserPoolId=userPoolId, ClientId=clients[clientName])

  userPoolClient = response['UserPoolClient']
  assert userPoolClient['ClientName'] == clientName

  callbackURLs = userPoolClient['CallbackURLs']
  if len(callbackURLs) != 1:
    raise CognitoException(f"Expected one callback (redirect_uri) but got: {len(callbackURLs)}")
  redirect_uri = callbackURLs[0]

  logoutURLs = userPoolClient['LogoutURLs']
  if len(logoutURLs) != 1:
    raise CognitoException(f"Expected one callback (logout_uri) but got: {len(logoutURLs)}")
  logout_uri = logoutURLs[0]

  # todo: get the domain prefix from the settings above.
  domainPrefix = "collections"

  response = client.describe_user_pool_domain(Domain=domainPrefix)
  domainDescription = response['DomainDescription']
  if len(domainDescription) == 0:
    raise CognitoException(f"The domain prefix doesn't exist: {domainPrefix}")

  ## cognito domain

  region = domainDescription['UserPoolId'].split('_')[0]
  domain = f"https://{domainPrefix}.auth.{region}.amazoncognito.com"

  config = {}
  config['client_id'] = userPoolClient['ClientId']
  config['redirect_uri'] = redirect_uri
  config['logout_uri'] = logout_uri
  config['scope'] = "openid profile"
  config['domain'] = domain
  settings['config'] = config

  return settings

def process(args):
  """
  """
  if args.listUsers:
    listUsers(args.listUsers)
  elif args.printPools:
    printPools()
  elif args.showPoolSettings:
    showPoolSettings(args.showPoolSettings)
  elif args.createPool:
    createPool(args.createPool)
  elif args.writeCognitoConfig:
    writeCognitoConfig(args.writeCognitoConfig)
  else:
    raise CognitoException(f"""No implementation for args:
{args}
""")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")

  parser.add_argument("-p", "--printPools", action='store_true',
    help="print (list) the pool names")

  parser.add_argument("-s", "--showPoolSettings", metavar="pool-name",
    help="show (list) the pool settings for the given cognito pool")

  parser.add_argument("-c", "--createPool", metavar="pool-name",
    help="create a cognito pool with the given name")

  parser.add_argument("-w", "--writeCognitoConfig", metavar="pool-name",
    help="write the ~/.aws/cognito-config file for use with the given pool.")

  parser.add_argument("-l", "--listUsers", metavar='pool-name',
    help="show the pool users for the given pool")

  parser.add_argument("-u", "--createUser", action="store_true",
    help="(not Implemented) create a new user")

  parser.add_argument("-e", "--editUser", metavar='user-id',
    help="(not Implemented) edit an existing user")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except CognitoException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

client = None

class TestCognito(unittest.TestCase):

  def setUpClass():
    global client
    client = getCognitoBoto3Client()

  def test_poolNameToId(self):
    pools = poolNameToId(client)
    printDict("\npools:", pools)

  def test_poolClientNameToId(self):
    pools = poolNameToId(client)
    print()
    print("pool clients:")
    for poolName, poolId in pools.items():
      clients = poolClientNameToId(client, poolId)
      printDict(poolName+":", clients)
    print()

  def test_getAttributes(self):
    cognito_attributes = [
      {'Name': 'email', 'Value': 'steve.flenniken@gmail.com'},
      {'Name': 'family_name', 'Value': 'Flenniken'},
      {'Name': 'given_name', 'Value': 'Steve'},
      {'Name': 'custom:admin', 'Value': '0'}
    ]
    d = getAttributes(cognito_attributes)
    self.assertEqual(d['email'], 'steve.flenniken@gmail.com')
    self.assertEqual(d['family_name'], 'Flenniken')
    self.assertEqual(d['given_name'], 'Steve')
    self.assertEqual(d['custom:admin'], '0')

  def test_formatDict1(self):
    d = {
      "a": 5,
      "b": "hello",
    }
    lines = []
    formatDict("name:", d, 0, lines)
    formatDict("name2:", d, 0, lines)
    # print("\n".join(lines))
    # print("----end----")
    got = '\n'.join(lines)
    expected = """\
name:
  a: 5
  b: 'hello'
name2:
  a: 5
  b: 'hello'"""
    self.assertEqual(got, expected)

  def test_formatDict(self):
    dt = datetime(2024, 6, 2, 4, 4, 42, 501295, tzinfo=timezone.utc)
    d = {
      "a": 5,
      "b": "hello",
      "date": dt,
      "list": [1, 2, 3, 4],
      "nested": {"n1": "asdf", "n2": "adsfasdf"},
      "list": [1, {"x":1, "y":2}, 3, 4, "hi"],
      "anotherdict": {"c": 5, "d": {}, "e": 42},
    }
    # print(d)
    lines = []
    formatDict("name:", d, 0, lines)
    got = '\n'.join(lines)

    expected = """\
name:
  a: 5
  b: 'hello'
  date: 2024-06-02 04:04:42 UTC
  list: [
    1
    {
      x: 1
      y: 2
    }
    3
    4
    hi
  ]
  nested:
    n1: 'asdf'
    n2: 'adsfasdf'
  anotherdict:
    c: 5
    d: {}
    e: 42"""
    self.assertEqual(got, expected)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
