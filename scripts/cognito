#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script is for setting up the cognito login system and managing users.

"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap
import boto3
from datetime import datetime, timezone

# The name of the application client of a pool created for
# collections.
appName = "CollectionsClient"

class CognitoException(Exception):
  """ An exception we plan for. """
  pass

def convertToKeyValue(cognito_attributes):
  """
  Convert the verbose cognito attributes to a dictionary of key
  value pairs.
  """

# convert:
#
# [
#   {
#     'Name': 'email', 'Value':
#     'steve.flenniken@gmail.com'
#   },
#   {
#     'Name': 'family_name',
#     'Value': 'Flenniken'
#   },
#   {
#     'Name': 'given_name',
#     'Value': 'Steve'
#   },
#   {
#     'Name': 'custom:admin',
#     'Value': '0'
#   }
# ]
#
# to:
#
# {
# 'email': 'steve.flenniken@gmail.com',
# 'family_name': 'Flenniken',
# 'given_name': 'Steve',
# 'custom:admin': 0
# }
  result = {}
  for d in cognito_attributes:
    result[d['Name']] = d['Value']
  return result

def formatDateTime(dt):
  """
  Format a datatime object and return something like: 2024-05-05 21:41:57 UTC
  """
  # https://strftime.org/
  # https://en.wikipedia.org/wiki/ISO_8601
  # return dt.strftime("%Y-%m-%dT%H:%M:%S%z")
  # return dt.astimezone().replace(microsecond=0).isoformat()
  return dt.strftime("%Y-%m-%d %H:%M:%S %Z")

def listUsers(poolName):
  """
  List the users in the given cognito user pool.
  """
  cognitoClient = getBotoClient()
  pools = poolNamesToIds(cognitoClient)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")

  response = cognitoClient.list_users(
    UserPoolId=pool[poolName],
    AttributesToGet=[ "email", "given_name", "family_name", 'custom:admin']
  )
  users = response['Users']

  print("id enabled admin status first last email created")
  for user in users:
    a = convertToKeyValue(user['Attributes'])
    # print(f"email: {a['email']}")
    # print(f"given_name: {a['given_name']}")
    # print(f"family_name: {a['family_name']}")
    # print(f"custom:admin: {a['custom:admin']}")
    # print(f"Username: {user['Username']}")
    # print(f"UserCreateDate: {formatDateTime(user['UserCreateDate'])}")
    # print(f"UserLastModifiedDate: {formatDateTime(user['UserLastModifiedDate'])}")
    # print(f"Enabled: {user['Enabled']}")
    # print(f"Enabled: {user['UserStatus']}")

    # Print a user per line.
    print(f"\
{user['Username']} \
{user['Enabled']} \
{a['custom:admin']} \
{user['UserStatus']} \
{a['given_name']} \
{a['family_name']} \
{a['email']} \
{formatDateTime(user['UserCreateDate'])}")

def getBotoClient(serviceName='cognito-idp'):
  """
  Return the boto3 client for the given AWS service. Services names
  like 'cognito-idp', 'ses', 'sts', etc.
  """
  configFilename = "/home/coder/.aws/config"
  credsFilename = "/home/coder/.aws/credentials"
  if not os.path.exists(configFilename) or not os.path.exists(credsFilename):
     raise CognitoException("""\

Before this script can access your aws cognito user pool, you need an
AWS account and an IAM user with with AmazonCognitoPowerUser and
AmazonSESReadOnlyAccess permissions.

Once the IAM user exists run "aws configure" and specify the IAM
user's credentials.  """)
  return boto3.client(serviceName)

def getEmailConfig(poolName, emailFromName):
  """
  Return a dictionary of the email configuration settings needed
  by the new pool (EmailConfiguration). Iterate the SES emails and use
  the one that is tagged with the given poolName.
  """

  # Get the SES emails.
  response = sesv2Client.list_email_identities()
  email_identities = response.get("EmailIdentities")
  if email_identities is None:
    raise CognitoException("No AWS SES emails are configured.")

  # Look through the emails looking for the one tagged with the given
  # poolName.
  for email_identity in email_identities:
    response = sesv2Client.get_email_identity(
        EmailIdentity=email_identity['IdentityName']
    )
    tags = response['tags']
    for tag in tags:
      if tag['key'] != 'poolName' or tag['value'] != poolName:
        continue
      if email_identity['IdentityType'] != 'EMAIL_ADDRESS':
        continue
      # Found the SES email associated with this pool.
      break
    else: # no break
      raise CognitoException(f"The ${poolName} tagged SES email was not found.")

  if email_identity['SendingEnabled'] != True:
    raise CognitoException(f"Found the ${poolName} tagged email but it isn't enabled.")
  if email_identity['VerificationStatus'] != "SUCCESS":
    raise CognitoException(f"Found the ${poolName} tagged email but it isn't verified yet.")

  replyToEmail = email_identity['IdentityName']

  # Get the AWS account number that we are running under.
  stsClient = getBotoClient('sts')
  response = stsClient.get_caller_identity()
  accountNumber = response['Account']

  # todo: How do you get the region the iam is currently using?
  # This is the region where the user pool will be created.  We need
  # the region to build the SourceArn for the ses email.
  region = 'us-west-2'

  sourceArn = f"arn:aws:ses:${region}:${accountNumber}:identity/${replyToEmail}"

  # todo: get the EmailSendingAccount field from aws ses.
  emailSendingAccount = 'DEVELOPER'

  emailConfiguration = {
    'SourceArn': sourceArn,
    'ReplyToEmailAddress': replyToEmail,
    'EmailSendingAccount': emailSendingAccount,
    'From': f'${emailFromName} <${replyToEmail}>',
  }
  return emailConfiguration

def createPool(poolName):
  """
  Create a pool with the given name. Prompt for other parameters when needed.
  """
  cognitoClient = getBotoClient()

  # Make sure the pool name doesn't already exist.
  pools = poolNamesToIds(cognitoClient)
  if poolName in pools:
    raise CognitoException("The user pool already exists.")

  msg = f"""\
What name should be used with From address of the emails cognito sends out?
For example, the placeholder "Steve Flenniken" is the From name below:

  Steve Flenniken <collections@flenniken.net>

Enter From name: """
  emailFromName = input(msg)

  # Return a dictionary of the email configuration settings needed by
  # the new pool. Look up the SES emails and use the one that is
  # tagged with poolName as this pool's name.
  emailConfiguration = getEmailConfig(poolName, emailFromName)

  # Look up the SES emails and use the one that is tagged with
  # poolName as this pool's name.
  response = sesv2Client.list_email_identities()
  email_identities = response.get("EmailIdentities")
  if email_identities is None:
    raise CognitoException("No AWS SES emails configured.")

  for email_identity in email_identities:
    response = sesv2Client.get_email_identity(
        EmailIdentity=email_identity['IdentityName']
    )

    tags = response['tags']
    for tag in tags:
      if tag['key'] == 'poolName' and tag['value'] == poolName:
        # Found the SES email associated with this pool.
        break
    else: # no break
      raise CognitoException("No AWS SES emails configured.")

  if email_identity['IdentityType'] != 'EMAIL_ADDRESS':
    raise CognitoException("No AWS SES emails configured.")
  if email_identity['SendingEnabled'] != True:
    raise CognitoException("No AWS SES emails configured.")
  if email_identity['VerificationStatus'] != "SUCCESS":
    raise CognitoException("No AWS SES emails configured.")

  replyToEmail = email_identity['IdentityName']

  # Get the AWS account number that we are running under.
  stsClient = getBotoClient('sts')
  response = stsClient.get_caller_identity()
  accountNumber = response['Account']

  # todo: How do you get the region the iam is currently using?
  # This is the region where the user pool will be created.  We need
  # the region to build the SourceArn for the ses email.
  region = 'us-west-2'

  sourceArn = f"arn:aws:ses:${region}:${accountNumber}:identity/${replyToEmail}"

  # todo: get the EmailSendingAccount field from aws ses.
  emailSendingAccount = 'DEVELOPER'

  msg = f"""\
What name should be used with "from" address of the emails cognito sends out?
For example, the placeholder "Steve Flenniken" is the from name below:

  Steve Flenniken <${replyToEmail}>

From name: """
  emailFromName = input(msg)


  # reference:
  # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cognito-idp/client/create_user_pool.html

  response = cognitoClient.create_user_pool(
    PoolName = poolName,
    # Use defaults for the commented out parameters.
    # Policies={
    #     'PasswordPolicy': {
    #         'MinimumLength': 123,
    #         'RequireUppercase': True|False,
    #         'RequireLowercase': True|False,
    #         'RequireNumbers': True|False,
    #         'RequireSymbols': True|False,
    #         'TemporaryPasswordValidityDays': 123
    #     }
    # },
    DeletionProtection='ACTIVE',
    # LambdaConfig={
    #     'PreSignUp': 'string',
    #     'CustomMessage': 'string',
    #     'PostConfirmation': 'string',
    #     'PreAuthentication': 'string',
    #     'PostAuthentication': 'string',
    #     'DefineAuthChallenge': 'string',
    #     'CreateAuthChallenge': 'string',
    #     'VerifyAuthChallengeResponse': 'string',
    #     'PreTokenGeneration': 'string',
    #     'UserMigration': 'string',
    #     'PreTokenGenerationConfig': {
    #         'LambdaVersion': 'V1_0'|'V2_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomSMSSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'CustomEmailSender': {
    #         'LambdaVersion': 'V1_0',
    #         'LambdaArn': 'string'
    #     },
    #     'KMSKeyID': 'string'
    # },
    AutoVerifiedAttributes=['email'],
    # AliasAttributes=['email'],
    UsernameAttributes=['email'],
    # VerificationMessageTemplate={
    #     'SmsMessage': 'string',
    #     'EmailMessage': 'string',
    #     'EmailSubject': 'string',
    #     'EmailMessageByLink': 'string',
    #     'EmailSubjectByLink': 'string',
    #     'DefaultEmailOption': 'CONFIRM_WITH_LINK'|'CONFIRM_WITH_CODE'
    # },
    # SmsAuthenticationMessage='string',
    # MfaConfiguration='OFF',
    # UserAttributeUpdateSettings={
    #     'AttributesRequireVerificationBeforeUpdate': [
    #         'phone_number'|'email',
    #     ]
    # },
    # DeviceConfiguration={
    #     'ChallengeRequiredOnNewDevice': True|False,
    #     'DeviceOnlyRememberedOnUserPrompt': True|False
    # },

    # ses:
    # https://boto3.amazonaws.com/v1/documentation/api/1.26.93/reference/services/ses.html

    # todo: add a note to the iam creation part about adding
    # AmazonSESReadOnlyAccess permissions to the iam user.

    EmailConfiguration=emailConfiguration,

    # SmsConfiguration={
    #     'SnsCallerArn': 'string',
    #     'ExternalId': 'string',
    #     'SnsRegion': 'string'
    # },
    # UserPoolTags={
    #     'string': 'string'
    # },
    AdminCreateUserConfig={
        'AllowAdminCreateUserOnly': True,
        # 'UnusedAccountValidityDays': 123,
        # 'InviteMessageTemplate': {
        #     'SMSMessage': 'string',
        #     'EmailMessage': 'string',
        #     'EmailSubject': 'string'
        # }
    },
    # Schema=[
    #     {
    #         'Name': 'string',
    #         'AttributeDataType': 'String'|'Number'|'DateTime'|'Boolean',
    #         'DeveloperOnlyAttribute': True|False,
    #         'Mutable': True|False,
    #         'Required': True|False,
    #         'NumberAttributeConstraints': {
    #             'MinValue': 'string',
    #             'MaxValue': 'string'
    #         },
    #         'StringAttributeConstraints': {
    #             'MinLength': 'string',
    #             'MaxLength': 'string'
    #         }
    #     },
    # ],
    # UserPoolAddOns={
    #     'AdvancedSecurityMode': 'OFF'
    # },
    # UsernameConfiguration={
    #     'CaseSensitive': False
    # },
    # AccountRecoverySetting={
    #     'RecoveryMechanisms': [
    #         {
    #             'Priority': 123,
    #             'Name': 'verified_email'|'verified_phone_number'|'admin_only'
    #         },
    #     ]
    # }
  )
  print(response)
  printDict("Response", response)

  # Create the pool client.
  response = cognitoClient.create_user_pool_client(
    UserPoolId=userPoolId,
    ClientName=appName,
    # GenerateSecret=True|False,
    # RefreshTokenValidity=123,
    # AccessTokenValidity=123,
    # IdTokenValidity=123,
    # TokenValidityUnits={
    #     'AccessToken': 'seconds'|'minutes'|'hours'|'days',
    #     'IdToken': 'seconds'|'minutes'|'hours'|'days',
    #     'RefreshToken': 'seconds'|'minutes'|'hours'|'days'
    # },
    ReadAttributes=[
      "email",
      "family_name",
      "given_name"
    ],
    WriteAttributes=[
      "email",
      "family_name",
      "given_name"
    ],
    ExplicitAuthFlows=[
      'ALLOW_REFRESH_TOKEN_AUTH',
      "ALLOW_USER_PASSWORD_AUTH"
    ],
    SupportedIdentityProviders=[
      "COGNITO"
    ],
    CallbackURLs=[
      "https://collections.flenniken.net/index.html"
    ],
    LogoutURLs=[
      'https://collections.flenniken.net/index.html'
    ],
    # DefaultRedirectURI='string',
    AllowedOAuthFlows=[
      'code'
    ],
    AllowedOAuthScopes=[
      'aws.cognito.signin.user.admin',
      'email',
      'openid',
      "phone",
      'profile'
    ],
    AllowedOAuthFlowsUserPoolClient=True,
    # AnalyticsConfiguration={
    #     'ApplicationId': 'string',
    #     'ApplicationArn': 'string',
    #     'RoleArn': 'string',
    #     'ExternalId': 'string',
    #     'UserDataShared': True|False
    # },
    PreventUserExistenceErrors='LEGACY',
    EnableTokenRevocation=True,
    EnablePropagateAdditionalUserContextData=False,
    AuthSessionValidity=5
  )

  msg = """\
The domainPrefix is used in the login and logout urls
with Amazon. It is a short string of lower case letters, digits,
underscores and hyphens. It must be unique with Amazon.

For example, "collections" is a domain prefix and it is used like:

https://collections.auth.us-west-2.amazoncognito.com

Enter the domain prefix: """
  domainPrefix = input(msg)

  response = cognitoClient.create_user_pool_domain(
      Domain=domainPrefix,
      UserPoolId=userPoolId,
      # CustomDomainConfig={
      #     'CertificateArn': 'string'
      # }
  )

def printDict(name, d):
  lines = []
  formatDict(name, d, 0, lines)
  print('\n'.join(lines))

def formatDict(name, d, indent=0, lines=[]):
  """
  Format a dictionary recursively and append lines to the lines
  parameter.
  """
  spaces = " " * indent
  spaces2 = spaces + "  "
  if len(d) == 0:
    lines.append(f"{spaces}{name} " + "{}")
  else:
    lines.append(f"{spaces}{name}")
  for k, v in d.items():
    if isinstance(v, datetime):
      value = formatDateTime(v)
    elif isinstance(v, dict):
      ind = indent + 2
      formatDict(k+":", v, ind, lines)
      continue
    elif isinstance(v, list):
      spaces4 = spaces2 + "  "
      lines.append("%s%s: [" % (spaces2, k))
      for item in v:
        if isinstance(item, dict):
          ind = indent + 4
          formatDict("{", item, ind, lines)
          lines.append(spaces4 + "}")
        else:
          lines.append("%s%s" % (spaces4, item))
      lines.append("%s]" % (spaces2))
      continue
    else:
      value = repr(v)
    lines.append("%s%s: %s" % (spaces2, k, value))

def poolNamesToIds(cognitoClient):
  """
  Return a dictionary mapping a pool name to a pool userPoolId for all
  the pools.
  """
  d = {}
  response = cognitoClient.list_user_pools(MaxResults=30)
  userPools = response.get('UserPools')
  for userPool in userPools:
    userPoolName = userPool["Name"]
    userPoolId = userPool['Id']
    d[userPoolName] = userPoolId
  return d

def writeCognitoConfig(poolName, domainPrefix):
  """
  Write the cognito config file: ~/.aws/cognito-config for the
  given the pool name and domain prefix.
  """
  settings = getPoolSettings(poolName)
  config = settings['config']

  # Write the cognito config file: ~/.aws/cognito-config.
  filename = "/home/coder/.aws/cognito-config"
  with open(filename, 'w') as fp:
    fp.write(json.dumps(config))

  print(f"""\
Wrote the cognito config file. View it with:

  cat {filename} | jqless
""")

def showPoolSettings(poolName):
  """
  Show the pool settings.
  """
  settings = getPoolSettings(poolName)
  printDict(poolName + ":", settings)

def printPools():
  """
  """
  # Get the pools.
  cognitoClient = getBotoClient()
  pools = poolNamesToIds(cognitoClient)
  for name in pools.keys():
    print(name)

  # cognitoClient = getBotoClient()
  # response = cognitoClient.list_user_pools(MaxResults=30)
  # userPools = response['UserPools']

  # for userPoolsBasic in userPools:
  #   name = userPoolsBasic['Name']
  #   userPoolId = userPoolsBasic['Id']
  #   print(f"  {name} {domainPrefix} '{appName}'")

  #   # Get the user pool information and pull out the domain prefix.
  #   response = cognitoClient.describe_user_pool(UserPoolId=userPoolId)
  #   if 'UserPool' not in response:
  #     raise CognitoException(f"UserPool was not in the response.")
  #   userPool = response['UserPool']
  #   domainPrefix = userPool['Domain']

  #   # Get the pool's application clients.
  #   response = cognitoClient.list_user_pool_clients(
  #       UserPoolId=userPoolId,
  #       MaxResults=30,
  #   )

  #   userPoolClients = response["UserPoolClients"]
  #   for userPoolClient in userPoolClients:
  #     appName = userPoolClient['ClientName']
  #     clientId = userPoolClient['ClientId']
  #     print(f"  {name} {domainPrefix} '{appName}'")

def poolAppNameToId(cognitoClient, userPoolId):
  """
  Return a dictionary mapping the pool application client names to
  their id.
  """

  # Get the pool's application clients.
  response = cognitoClient.list_user_pool_clients(
    UserPoolId=userPoolId,
    MaxResults=30,
  )
  userPoolClients = response.get("UserPoolClients")

  # Build and return a dictionary mapping name to id.
  clients = {}
  for userPoolClient in userPoolClients:
    clientName = userPoolClient['ClientName']
    clientId = userPoolClient['ClientId']
    clients[clientName] = clientId
  return clients

def getPoolSettings(poolName):
  """
  Return the pool setting in a dictionary. The config key contains
  a dictionary for the cognito_config file.
  """
  # If the pool has more than one application client, prompt for the one to use?

  # Get the pool id of the given pool name.
  cognitoClient = getBotoClient()
  pools = poolNamesToIds(cognitoClient)
  if poolName not in pools:
    raise CognitoException("The user pool doesn't exist.")
  userPoolId = pools[poolName]

  # Get the user pool settings.
  settings = {}
  response = cognitoClient.describe_user_pool(UserPoolId=userPoolId)
  if 'UserPool' not in response:
    raise CognitoException(f"UserPool was not in the response.")
  settings['UserPool'] = response['UserPool']

  # Find the collections application client.
  poolApps = poolAppNameToId(cognitoClient, userPoolId)
  if appName not in poolApps:
    raise CognitoException(
      f"The pool doesn't have an application client called {appName}.")

  # Get the settings for the collection's application client.
  response = cognitoClient.describe_user_pool_client(
    UserPoolId=userPoolId, ClientId=poolApps[appName])
  userPoolClient = response['UserPoolClient']
  assert userPoolClient['ClientName'] == appName

  # Verify there is one redirect uri.
  callbackURLs = userPoolClient['CallbackURLs']
  if len(callbackURLs) != 1:
    raise CognitoException(f"Expected one redirect_uri but got: {len(callbackURLs)}")
  redirect_uri = callbackURLs[0]

  # Verify there is one callback uri.
  logoutURLs = userPoolClient['LogoutURLs']
  if len(logoutURLs) != 1:
    raise CognitoException(f"Expected one logout_uri but got: {len(logoutURLs)}")
  logout_uri = logoutURLs[0]

  # todo: get the domain prefix from the settings above.
  domainPrefix = "collections"

  # Verify there is a domain prefix.
  response = cognitoClient.describe_user_pool_domain(Domain=domainPrefix)
  domainDescription = response['DomainDescription']
  if len(domainDescription) == 0:
    raise CognitoException(f"The domain prefix doesn't exist: {domainPrefix}")

  # Create the cognito domain from the domain prefix and the region
  # extracted from the description.
  region = domainDescription['UserPoolId'].split('_')[0]
  domain = f"https://{domainPrefix}.auth.{region}.amazoncognito.com"

  # Assign the config dictionary and add it to the return settings for
  # use by the congnito-config file.
  config = {}
  config['client_id'] = userPoolClient['ClientId']
  config['redirect_uri'] = redirect_uri
  config['logout_uri'] = logout_uri
  config['scope'] = "openid profile"
  config['domain'] = domain
  settings['config'] = config

  return settings

def process(args):
  """
  """
  if args.listUsers:
    listUsers(args.listUsers)
  elif args.printPools:
    printPools()
  elif args.showPoolSettings:
    showPoolSettings(args.showPoolSettings)
  elif args.createPool:
    createPool(args.createPool)
  elif args.writeCognitoConfig:
    writeCognitoConfig(args.writeCognitoConfig)
  else:
    raise CognitoException(f"""No implementation for args:
{args}
""")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")

  parser.add_argument("-p", "--printPools", action='store_true',
    help="print (list) the pool names")

  parser.add_argument("-s", "--showPoolSettings", metavar="pool-name",
    help="show (list) the pool settings for the given cognito pool")

  parser.add_argument("-c", "--createPool", metavar="pool-name",
    help="create a cognito pool with the given name")

  parser.add_argument("-w", "--writeCognitoConfig", metavar="pool-name",
    help="write the ~/.aws/cognito-config file for use with the given pool.")

  parser.add_argument("-l", "--listUsers", metavar='pool-name',
    help="show the pool users for the given pool")

  parser.add_argument("-u", "--createUser", action="store_true",
    help="(not Implemented) create a new user")

  parser.add_argument("-e", "--editUser", metavar='user-id',
    help="(not Implemented) edit an existing user")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except CognitoException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

cognitoClient = None
sesClient = None
sesv2Client = None
stsClient = None

class TestCognito(unittest.TestCase):

  def setUpClass():
    # Get the boto clients we test. This method is called once by the
    # test suite. The code is here to avoid a runtime error in the
    # shutdown phase.
    global cognitoClient
    global sesClient
    global sesv2Client
    global stsClient
    cognitoClient = getBotoClient()
    sesClient = getBotoClient('ses')
    sesv2Client = getBotoClient('sesv2')
    stsClient = getBotoClient('sts')

  def test_poolNamesToIds(self):
    pools = poolNamesToIds(cognitoClient)
    printDict("\npools:", pools)

  def test_poolAppNameToId(self):
    pools = poolNamesToIds(cognitoClient)
    print()
    print("pool clients:")
    for poolName, poolId in pools.items():
      clients = poolAppNameToId(client, poolId)
      printDict(poolName+":", clients)
    print()

  def test_convertToKeyValue(self):
    cognito_attributes = [
      {'Name': 'email', 'Value': 'steve.flenniken@gmail.com'},
      {'Name': 'family_name', 'Value': 'Flenniken'},
      {'Name': 'given_name', 'Value': 'Steve'},
      {'Name': 'custom:admin', 'Value': '0'}
    ]
    d = convertToKeyValue(cognito_attributes)
    self.assertEqual(d['email'], 'steve.flenniken@gmail.com')
    self.assertEqual(d['family_name'], 'Flenniken')
    self.assertEqual(d['given_name'], 'Steve')
    self.assertEqual(d['custom:admin'], '0')

  def test_formatDict1(self):
    d = {
      "a": 5,
      "b": "hello",
    }
    lines = []
    formatDict("name:", d, 0, lines)
    formatDict("name2:", d, 0, lines)
    # print("\n".join(lines))
    # print("----end----")
    got = '\n'.join(lines)
    expected = """\
name:
  a: 5
  b: 'hello'
name2:
  a: 5
  b: 'hello'"""
    self.assertEqual(got, expected)

  def test_formatDict(self):
    dt = datetime(2024, 6, 2, 4, 4, 42, 501295, tzinfo=timezone.utc)
    d = {
      "a": 5,
      "b": "hello",
      "date": dt,
      "list": [1, 2, 3, 4],
      "nested": {"n1": "asdf", "n2": "adsfasdf"},
      "list": [1, {"x":1, "y":2}, 3, 4, "hi"],
      "anotherdict": {"c": 5, "d": {}, "e": 42},
    }
    # print(d)
    lines = []
    formatDict("name:", d, 0, lines)
    got = '\n'.join(lines)

    expected = """\
name:
  a: 5
  b: 'hello'
  date: 2024-06-02 04:04:42 UTC
  list: [
    1
    {
      x: 1
      y: 2
    }
    3
    4
    hi
  ]
  nested:
    n1: 'asdf'
    n2: 'adsfasdf'
  anotherdict:
    c: 5
    d: {}
    e: 42"""
    self.assertEqual(got, expected)

  def test_aws_api(self):

    # Returns a list containing all of the identities (email addresses
    # and domains) for your AWS account in the current AWS Region,
    # regardless of verification status.
    response = sesClient.list_identities(MaxItems=30)
    printDict("list_identities", response)
    return

    # response = sesClient.list_identity_policies(
    #   Identity='flenniken.net',
    # )
    # print("\nlist_identity_policies:")
    # print(response)
    # # no policies: 'PolicyNames': []

    # response = sesClient.get_account_sending_enabled()
    # printDict("account_sending_enabled", response)

    # response = sesClient.get_identity_mail_from_domain_attributes(
    #   Identities=['flenniken.net']
    # )
    # printDict("get_identity_mail_from_domain_attributes", response)

    # response = sesClient.get_identity_notification_attributes(
    #   Identities=['flenniken.net']
    # )
    # printDict("get_identity_notification_attributes", response)

    # response = sesClient.get_identity_verification_attributes(
    #   Identities=['flenniken.net']
    # )
    # printDict("get_identity_verification_attributes", response)


    # response = sesClient.get_send_quota()
    # printDict("get_send_quota", response)

    # # You can specify an identity by using its name or by using its
    # # Amazon Resource Name (ARN). Examples: user@example.com,
    # # example.com,
    # # arn:aws:ses:us-east-1:123456789012:identity/example.com

    # # Tells what a ARN is and how to generate one:
    # # https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html

    # # the console shows the arn.
    # # arn:aws:ses:us-west-2:169317056116:identity/collections@flenniken.net

    # response = sesv2Client.get_account()
    # printDict("get_account", response)

    # # response = client.list_tags_for_resource(
    # #     ResourceArn='string'
    # # )

    # response = sesv2Client.get_email_identity(
    #     EmailIdentity='collections@flenniken.net'
    # )
    # printDict("get_email_identity", response)

    # response = sesv2Client.list_email_identities()
    # printDict("list_email_identities", response)

    def test_getAccountNumber(self):
      response = stsClient.get_caller_identity()
      printDict("get_caller_identity", response)
      # accountNumber = response['Account']

    def test_getEmailConfig(self):
      emailConfiguration = getEmailConfig("poolName", "emailFromName")
      printDict("getEmailConfig", emailConfiguration)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
