#!/usr/bin/python3

# This is the help text shown with -h:

"""
Deploy the modified website files to s3 and invalidate them in the
cloudfront cache.
"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from collections import namedtuple
import json
import requests
import jwt
import subprocess
import sys
import textwrap
import random
import string
import botocore
import boto3
from datetime import datetime, timezone
from getpass import getpass

class DeployException(Exception):
  """ An exception we plan for. """
  pass

def getAwsSettings():
  """ Get the aws settings from the env/aws-settings.json file. """
  with open('/home/coder/collections/env/aws-settings.json', 'r') as file:
    return json.load(file)

def listS3(bucket_name):
  """ List the S3 files in the collection's bucket. """

  # Python boto3 docs for S3:
  # https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/s3

  s3Client = getBotoClient('s3')

  response = s3Client.list_objects_v2(Bucket=bucket_name)
  # print(json.dumps(response, default=str))

  # "Contents": [
  #   {
  #     "Key": "collections.css",
  #     "LastModified": "2024-11-23 20:19:33+00:00",
  #     "ETag": "\"9a0da3be7efd0bff1fb5e94874eb5f16\"",
  #     "Size": 2970,
  #     "StorageClass": "STANDARD"
  #   },

  # List the S3 files.
  for info in response.get("Contents"):
    timeStr = str(info['LastModified'])[0:-6]
    print(f"{timeStr} {info['Size']:8.0f} {info['Key']}")

def sync(bucket_name, distribution_id):
  """
  Copy the modified website files to S3 and invalidate them in the
  cloudfront cache.
  """
  modifiedFiles = syncModifiedFiles(bucket_name)
  if modifiedFiles:
    paths = []
    for filename in modifiedFiles:
      assert(filename.startswith("dist"))
      # remove the leading "dist", leaving /index.htm for example.
      paths.append(filename[4:])
    invalidateCloudFrontCache(distribution_id, paths)
    for path in paths:
      print(path)

def invalidateCloudFrontCache(distribution_id, paths):
  """
  Invalidate the cloudfront distribution cache for the given list
  of filenames.
  """
  cloudfront = getBotoClient('cloudfront')

  # Invalidate a list of filenames. Names start with a slash.
  response = cloudfront.create_invalidation(
    DistributionId=distribution_id,
    InvalidationBatch={
      'Paths': {
        'Quantity': len(paths),
        'Items': paths
      },
      'CallerReference': str(datetime.now().timestamp())
    }
  )
  
def listModified(bucket_name):
  """
  List the modified website files.
  """
  modifiedFiles = syncModifiedFiles(bucket_name, dryrun=True)
  for filename in modifiedFiles:
    print(filename)

def syncModifiedFiles(bucket_name, dryrun=False):
  """
  Sync the modified website files and return the files that needed
  to be synced.  If dryrun is true, the files are not synced but the
  modified files are still returned. The modified files are in the
  dist folder, e.g. dist/index.html
  """
  # sample output from the sync command:
  # (dryrun) upload: dist/index.html to s3://sflennikco/index.html
  # (dryrun) upload: dist/js/image.js to s3://sflennikco/js/image.js

  if dryrun:
    command = f"aws s3 sync --no-progress --dryrun dist s3://{bucket_name}" + " | awk '{print $3}'"
  else:
    command = f"aws s3 sync --no-progress dist s3://{bucket_name}" + " | awk '{print $2}'"
  # print(command)
  result = subprocess.run(command, shell=True, capture_output=True, text=True)
  text = result.stdout

  # Return a list of the modified filenames.
  filenames = []
  lines = text.split('\n')
  for line in lines:
    if line:
      filenames.append(line)
  return filenames

def getBotoClient(serviceName='s3'):
  """
  Return the boto3 client for the given AWS service. Services names
  like 'cognito-idp', 'ses', 'sts', etc.
  """
  configFilename = "/home/coder/.aws/config"
  credsFilename = "/home/coder/.aws/credentials"
  if not os.path.exists(configFilename) or not os.path.exists(credsFilename):
     raise DeployException("""\

Before this script can access your aws s3 bucket, you need an
AWS account and an IAM user with with the correct permissions.
See the docs for how to setup the IAM user.
""")
  return boto3.client(serviceName)

def printDict(name, d):
  lines = []
  formatDict(name, d, 0, lines)
  print('\n'.join(lines))

def formatDict(name, d, indent=0, lines=[]):
  """
  Format a dictionary recursively and append lines to the lines
  parameter.
  """
  spaces = " " * indent
  spaces2 = spaces + "  "
  if len(d) == 0:
    lines.append(f"{spaces}{name} " + "{}")
  else:
    lines.append(f"{spaces}{name}")
  for k, v in d.items():
    if isinstance(v, datetime):
      value = formatDateTime(v)
    elif isinstance(v, dict):
      ind = indent + 2
      formatDict(k+":", v, ind, lines)
      continue
    elif isinstance(v, list):
      spaces4 = spaces2 + "  "
      lines.append("%s%s: [" % (spaces2, k))
      for item in v:
        if isinstance(item, dict):
          ind = indent + 4
          formatDict("{", item, ind, lines)
          lines.append(spaces4 + "}")
        else:
          lines.append("%s%s" % (spaces4, item))
      lines.append("%s]" % (spaces2))
      continue
    else:
      value = repr(v)
    lines.append("%s%s: %s" % (spaces2, k, value))

def process(args):
  """ Handle the command specified. """

  if args.sync or args.listS3 or args.listModified:
    awsSettings = getAwsSettings()
    settings = awsSettings['settings']
    bucket_name = settings['bucket_name']
    if args.listS3:
      listS3(bucket_name)
      return
    elif args.sync:
      sync(bucket_name, settings['distribution_id'])
      return
    elif args.listModified:
      listModified(bucket_name)
      return

  raise DeployException("Invalid argument")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    # You can run one test by providing the test name as an argument.
    # deploy -t TestModule.test_me
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run all or one internal unit tests. You can run just one like this:  deploy -t TestModule.test_me")

  parser.add_argument("-l", "--listS3", action='store_true',
    help="list the first 1,000 collections files in S3 ")

  parser.add_argument("-s", "--sync", action='store_true',
    help="copy the modified files to S3 and invalidate them in the cloudfront cache")

  parser.add_argument("-m", "--listModified", action='store_true',
    help="list the modified files")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except DeployException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success


class TestClients:
  def __init__(self):
    self.s3Client = getBotoClient('s3')
    self.sesClient = getBotoClient('cloudfront')

tc = None

def setUpModule():
  # Get the boto clients we test. This method is called once by the
  # test suite. The code is here to avoid a runtime error in the
  # shutdown phase.
  global tc
  tc = TestClients()

def tearDownModule():
  pass

class TestModule(unittest.TestCase):

  def test_me(self):
    self.assertTrue(1)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
