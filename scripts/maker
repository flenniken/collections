#!/usr/bin/python3

# This is the help text shown with -h:

"""
Make a new collection from a folder of images or create
a collections.json. See collection-maker.md for a guide to
making collections.
"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

# Check that this script is run from the collections folder
cwd = os.getcwd()
if not cwd.endswith("collections"):
  print(f"""\
Run from the collections folder:
cd ~/collections
scripts/maker
""")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import tempfile
import json
import sys
import textwrap
from boto_client import getBotoClient, getAwsSettings
import random
import string
import shutil
from PIL import Image

thumbnailDim = 480
previewMinDim = 933

workingDir='/home/coder/collections'

# Folder where the new collection folder exists.
tmpFolder=f'{workingDir}/tmp'

collectionPrefix = 'db/c'
publishedPrefix = 'db/published-'

# True when the internet connection is working.
internet = True

class MakerException(Exception):
  """ An exception we plan for. """
  pass

class FileInfo(object):
  """
  File information important for a Collection.
  """
  def __init__(self, basename, isFile, size):
    self.basename = basename
    self.isFile = isFile
    self.size = size
  def __str__(self):
    isFileStr = "file" if self.isFile else "-"
    return f"{isFileStr:4} {self.size:8} {self.basename}"

def getFileInfoList(folder):
  """
  Return information about each file in a folder.
  """
  fileInfoList = []
  for entry in os.scandir(folder):
    stats = entry.stat()
    fileInfo = FileInfo(
      entry.name,
      entry.is_file(),
      stats.st_size,
    )
    fileInfoList.append(fileInfo)
  # Sort the fileInfoList by basename.
  fileInfoList.sort(key=lambda x: x.basename)
  return fileInfoList

class FileTypeGroups(object):
  """
  Holds the file information for a collection folder organized by
  the file type.
  """
  def __init__(self, fileInfoList):
    self.previews = []
    self.thumbnails = []
    self.jsonFiles = []
    self.htmlFilesI = []
    self.htmlFilesT = []
    self.other = []
    for fileInfo in fileInfoList:
      filename = os.path.basename(fileInfo.basename)
      if filename.endswith("-p.jpg"):
        self.previews.append(fileInfo)
      elif filename.endswith("-t.jpg"):
        self.thumbnails.append(fileInfo)
      elif filename.endswith(".json"):
        self.jsonFiles.append(fileInfo)
      elif filename.startswith("image-") and filename.endswith(".html"):
        self.htmlFilesI.append(fileInfo)
      elif filename.startswith("thumbnails-") and filename.endswith(".html"):
        self.htmlFilesT.append(fileInfo)
      else:
        self.other.append(fileInfo)

class ImageInfo(object):
  """
  Holds the information about an image file that is important for
  a collection.
  """
  def __init__(self, width, height, kind):
    self.width = width
    self.height = height
    self.kind = kind

  @classmethod
  def fromFile(cls, filename):
    """
    Create an ImageInfo object from a file.
    """
    try:
      with Image.open(filename) as img:
        width, height = img.size
        return cls(width, height, img.format)
    except Exception as ex:
      raise MakerException(f"Error: unable to open the image file: {filename}")

  def __str__(self):
    return f"{self.kind} ({self.width} x {self.height})"

def getImageInfoList(folder, fileInfoList, previews=True):
  """
  Return the image information as a list of ImageInfo objects.
  Previews is True when the fileInfoList is for previews, False
  when it is for thumbnails. If the image is the wrong size or
  not a jpg, raise an exception.
  """
  imageInfoList = []

  for ix, fileInfo in enumerate(fileInfoList):
    fullPath = os.path.join(folder, fileInfo.basename)
    ii = ImageInfo.fromFile(fullPath)
    if ii.kind != "JPEG":
      raise MakerException(f"""\
Error: image must be a jpg.
file: ({pii.width} x {pii.height}) {fullPath}
""")
    if previews:
      if ii.width < previewMinDim or ii.height < previewMinDim:
        raise MakerException(
          f"""\
Error: preview width and hight must greater than or equal to {previewMinDim}.
file: ({ii.width} x {ii.height}) {fileInfo.basename}
"""
        )
    else:
      if ii.width != thumbnailDim or ii.height != thumbnailDim:
        raise MakerException(
          f"""\
Error: thumbnail must be square ({thumbnailDim} x {thumbnailDim}).
file: ({ii.width} x {ii.height}) {fileInfo.basename}
"""
        )
    imageInfoList.append(ii)
  return imageInfoList

def validateCollectionFolder(num, ftg):
  """
  Validate that the given files work as a collection. Num is the
  collection number. No files are read.
  """
  numPreviews = len(ftg.previews)
  numThumbnails = len(ftg.thumbnails)
  numJson = len(ftg.jsonFiles)
  numHtmlI = len(ftg.htmlFilesI)
  numHtmlT = len(ftg.htmlFilesT)
  numOther = len(ftg.other)

  if numPreviews == 0:
    raise MakerException(f"Error: no previews files that end in -p.jpg.")
  if numThumbnails == 0:
    raise MakerException(f"Error: no thumbnails files that end in -t.jpg.")

  if numPreviews != len(ftg.thumbnails):
    raise MakerException(
      f"Error: mismatch: {numPreviews} previews != {numThumbnails} thumbnails.")
  if numThumbnails < 8:
    raise MakerException(f"Error: {numThumbnails} images, you need at least 8.")
  if numThumbnails > 20:
    raise MakerException(f"Error: {numThumbnails} images, you are limited to 20.")
  if numJson > 1:
    raise MakerException(f"Error: {numJson} json files, expected 1.")
  if numJson == 1:
    fileInfo = ftg.jsonFiles[0]
    if fileInfo.basename != f"c{num}.json":
      raise MakerException(f"Error: invalid cjson name for this collection: {fileInfo.basename}")

  if numHtmlI > 1:
    raise MakerException(f"Error: {numHtmlI} image html files, expected 1.")
  if numHtmlI == 1:
    fileInfo = ftg.htmlFilesI[0]
    if fileInfo.basename != f"image-{num}.html" :
        raise MakerException(
          f"Error: invalid image html name for this collection: {fileInfo.basename}")

  if numHtmlT > 1:
    raise MakerException(f"Error: {numHtmlT} thumbnails html files, expected 1.")
  if numHtmlT == 1:
    fileInfo = ftg.htmlFilesT[0]
    if fileInfo.basename != f"thumbnails-{num}.html":
        raise MakerException(
          f"Error: invalid thumbnails html name for this collection: {fileInfo.basename}")

  if numOther:
    first = ftg.other[0].basename
    raise MakerException(
      f"Error: there are {numOther} extra files in the folder, first: {first}")

def createCollectionCinfo(num, ftg, previewImageInfoList):
  """
  Create the collection info (cinfo) for the given collection number
  """
  assert len(ftg.previews) == len(ftg.thumbnails)
  images = []
  order = []

  for ix, fileInfo in enumerate(ftg.previews):
    thumbnailFileInfo = ftg.thumbnails[ix]
    previewImageInfo = previewImageInfoList[ix]

    collectionImage = {}
    collectionImage['title'] = ""
    collectionImage['description'] = ""

    collectionImage['url'] = getStdImageName(num, ix, "preview", "path")
    collectionImage['width'] = previewImageInfo.width
    collectionImage['height'] = previewImageInfo.height
    collectionImage['size'] = fileInfo.size

    collectionImage['thumbnail'] = getStdImageName(num, ix, "thumbnail", "path")
    collectionImage['sizet'] = thumbnailFileInfo.size
    images.append(collectionImage)
    order.append(-1)

  # Create the collection info (cinfo).
  cinfo = {
    "title": "",
    "description": "",
    "collection": num,
    "width": thumbnailDim,
    "height": thumbnailDim,
    "order": order,
    "images": images,
  }
  return cinfo

def getStdImageName(num, ix, kind, part):
  if kind == 'preview':
    prefix = 'p'
  elif kind == 'thumbnail':
    prefix = 't'
  else:
    raise MakerException(f"Invalid kind, expected preview or thumbnail.")

  name = f"c{num}-{ix+1}-{prefix}.jpg"

  if part == 'basename':
    return name
  elif part == 'path':
    return f"/images/c{num}/{name}"
  else:
    raise MakerException(f"Invalid part, expected basename or path.")


def renameFiles(num, folder, ftg):
  """
  Rename the image files in the given folder to use the standard
  collection naming based on the collection number an their index.
  """
  assert len(ftg.previews) == len(ftg.thumbnails)

  for ix in range(len(ftg.previews)):
    previewName = os.path.join(folder, ftg.previews[ix].basename)
    thumbnailName = os.path.join(folder, ftg.thumbnails[ix].basename)

    stdImageName = os.path.join(folder, getStdImageName(num, ix, "preview", "basename"))
    stdThumbnailName = os.path.join(folder, getStdImageName(num, ix, "thumbnail", "basename"))

    os.rename(previewName, stdImageName)
    os.rename(thumbnailName, stdThumbnailName)

def getNextCollectionNum(s3Client):
  """
  Return the next available collection number.
  """
  awsSettings = getAwsSettings()
  settings = awsSettings['settings']
  bucket_name = settings['bucket_name']

  prefixes = readDbPrefixes(s3Client, bucket_name)

  num = nextDbNum(prefixes)
  return num

def nextDbNum(prefixes):
  """
  Return the next collection number given a list of db prefixes.
  """
  num = 0
  for prefix in prefixes:
    if prefix.startswith(collectionPrefix):
      start = len(collectionPrefix)
    elif prefix.startswith(publishedPrefix):
      start = len(publishedPrefix)
    else:
      continue
    pnum = int(prefix[start:])
    if pnum > num:
      num = pnum
  nextNum = num + 1
  return nextNum

def reserveCollectionNum(s3Client, num):
  """
  Reserve the collection number.
  """
  # Determine the next from the current list the db prefix items.

  awsSettings = getAwsSettings()
  settings = awsSettings['settings']
  bucket_name = settings['bucket_name']

  prefixes = readDbPrefixes(s3Client, bucket_name)

  nextNum = nextDbNum(prefixes)
  if nextNum != num:
    raise MakerException(f"Error: the collection number is not available, use: {nextNum}.")

  writeDbPrefix(s3Client, bucket_name, "c", nextNum)
  return nextNum

def readDbPrefixes(s3Client, bucket_name):
  """
  Read the prefixes that start with db/.
  """
  bucket_name = 'sflennikco'
  prefix = "db/"
  response = s3Client.list_objects_v2(Bucket=bucket_name, Prefix=prefix)
  prefixes = []
  if 'Contents' in response:
    for obj in response['Contents']:
      prefixes.append(obj['Key'])
  return prefixes

def makeDbPrefix(kind, num):
  assert int(num) > 0
  if kind == "c":
    prefix = f"{collectionPrefix}{num}"
    content = 'collection under development'
  elif kind == "published":
    prefix = f"{publishedPrefix}{num}"
    content = 'published collection'
  else:
    raise MakerException(f"Error: invalid prefix kind.")
  return prefix, content

def writeDbPrefix(s3Client, bucket_name, kind, num):
  """
  Write the db prefix. kind is "c" or "published" and num is the
  collection number.
  """
  prefix, content = makeDbPrefix(kind, num)
  s3Client.put_object(Bucket=bucket_name, Key=prefix, Body=content)

def deleteDbPrefix(s3Client, bucket_name, kind, num):
  """
  Remove a db prefix.  kind is "c" or "published" and num is the
  collection number.
  """
  prefix, content = makeDbPrefix(kind, num)

  s3Client.delete_object(Bucket=bucket_name, Key=prefix)

def new(num):
  """
  Create a new local collection folder from a folder of images.
  """
  assert int(num) > 0

  sourceFolder = os.path.join(tmpFolder, str(num))
  if not os.path.exists(sourceFolder):
    raise MakerException(f"Missing the collection folder: {sourceFolder}")

  s3client = getBotoClient('s3')
  nextNum = getNextCollectionNum(s3client)
  if num != nextNum:
    raise MakerException(f"Error: the collection number is not available, use: {nextNum}.")

  localDestFolder = f"dist/images/c{num}"
  if os.path.exists(localDestFolder):
    raise MakerException(f"The local collection folder already exists: {localDestFolder}")

  # Get names and info of all the files in the sourceFolder and
  # validate that they work in a collection.
  fileInfoList = getFileInfoList(sourceFolder)
  ftg = FileTypeGroups(fileInfoList)
  validateCollectionFolder(num, ftg)

  # Validate the image dimensions and return the preview image information.
  previewImageInfoList = getImageInfoList(sourceFolder, ftg.previews, previews=True)
  getImageInfoList(sourceFolder, ftg.thumbnails, previews=False)

  # Write the cjson file in the tmp folder.
  cinfo = createCollectionCinfo(num, ftg, previewImageInfoList)
  cjsonFilename = os.path.join(sourceFolder, f"c{num}.json")
  with open(cjsonFilename, "w") as fh:
    fh.write(json.dumps(cinfo, indent=2))

  # Reserve the collection number for this collection.
  reserveCollectionNum(s3client, num)

  # Rename the images in the tmp folder to their standard names.
  renameFiles(num, sourceFolder, ftg)

  # Move the tmp folder to the local images folder.
  os.rename(sourceFolder, localDestFolder)

  print(f"Reserved collection {num}.")
  print(f"Created a collection folder and moved it to: {localDestFolder}")

def collections():
  """
  Create a collections.json file from all the cjson files in the local images folder.
  """
  # Get the list of all the collection folders.
  collectionFolders = []
  for entry in os.scandir("dist/images"):
    if entry.is_dir():
      collectionFolders.append(entry.name)
  # Sort the collection folders from newest to oldest.
  collectionFolders.sort(reverse=True)

  # Read the cjson files and create the collections.json file.
  collectionsJson = {"collections": []}
  collections = collectionsJson["collections"]
  for folder in collectionFolders:
    cjsonFilename = os.path.join("dist/images", folder, f"{folder}.json")
    with open(cjsonFilename, "r") as fh:
      cinfo = json.load(fh)
      print(f"Processing collection: {cinfo['collection']}")
      collection = {}
      collection['collection'] = cinfo["collection"]
      collection['ready'] = cinfo["ready"]
      collection['title'] = cinfo['title']
      collection['indexDescription'] = cinfo['indexDescription']
      collection['thumbnail'] = cinfo["indexThumbnail"]
      collection['posted'] = cinfo["posted"]
      collection["iCount"] = len(cinfo["images"])
      totalSize = 0
      for image in cinfo["images"]:
        totalSize += image["size"]
        totalSize += image["sizet"]
      collection["totalSize"] = totalSize

      collections.append(collection)

  # Write the collections.json file.
  filename = os.path.join("pages", "collections.json")
  with open(filename, "w") as fh:
    fh.write(json.dumps(collectionsJson, indent=2))

  print(f"Created the file: {filename}")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test=True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="""run internal unit test(s). "scripts/maker -t     shutil.rmtree(folder)    shutil.rmtree(folder)    shutil.rmtree(folder)    shutil.rmtree(folder)    shutil.rmtree(folder).test_me" or use alone to run all tests.""")
  parser.add_argument("-n", "--new", type=int, metavar="collectionNum",
    help="create a new local collection folder from a directory of images")
  parser.add_argument("-c", "--collections", action="store_true",
    help="create a collections.json file from all the cjson files")

  args = parser.parse_args(sys.argv[1:])

  # Note: when -t is specified, the code doesn't reach this point.

  if "help" in args and args.help:
    parser.print_help()
    sys.exit(1)

  return args

def process(args):
  """
  Handle the maker command's options.
  """
  if args.new:
    new(args.new)
  elif args.collections:
    collections()

def main(args):
  def signalHandler(sig, frame):
    """ Handle ctrl-C """
    sys.exit(1)
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except MakerException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

# Test code:

def testGetCollectionImagesError(previews, thumbnails, eMessage):
  """
  Test getCollectionImages errors, pass in the expected error message.
  """
  try:
    getCollectionImages(1, previews, thumbnails)
    assert False, "Unexpectedly passed"
  except MakerException as ex:
    gotExpected(str(ex), eMessage)
    return # passed
  assert False, "Got an unexpected exception."

def gotExpected(got, expected):
  if got != expected:
    msg = f"""
---
     got: {got}
expected: {expected}
---
"""
    assert False, msg

def pv(name, value):
  print(f"{name}: {value}")

def fail(msg):
  assert 0 == 1, msg

def testGetImageInfoError(filename, eMsg):
  """
  Test getImageInfo errors, pass in the expected error message.
  """
  try:
    ImageInfo.fromFile(filename)
    fail("Unexpectedly passed")
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")

def testValidateFolderError(num, previews=8, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, others=0, eMsg=""):
  try:
    folder = makeTestFolder(num, previews=previews, thumbnails=thumbnails,
      cjson=cjson, imageHtml=imageHtml, thumbnailHtml=thumbnailHtml, others=others)
    fileInfoList = getFileInfoList(folder)
  finally:
    shutil.rmtree(folder)

  ftg = FileTypeGroups(fileInfoList)

  try:
    validateCollectionFolder(num, ftg)
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")

def randomName(folder, k=6, prefix="", postfix=""):
  """
  Return a random name in the given folder with the
  given prefix and postfix.
  """
  randomPart = random62(k)
  return os.path.join(folder, f"{prefix}{randomPart}{postfix}")

def random62(k):
  """
  Return a random base 62 number of the given length.
  """
  characters = string.ascii_letters + string.digits
  return ''.join(random.choices(characters, k=k))

def createFile(filename, contents):
  """ Create a new file with the given contents. """
  with open(filename, 'w+', encoding='utf-8') as fh:
    fh.write(contents)

def makeTestFolder(num, previews=8, thumbnails=8, cjson=1,
  imageHtml=1, thumbnailHtml=1, others=0):
  """
  Make a collection folder in the temp dir for testing. Return the
  folder name.  When done with the folder delete it with:
  shutil.rmtree(folder)
  """

  # Create a temp folder and fill it with the specified number of fake
  # small files.

  folder = tempfile.mkdtemp(prefix="maker-")

  for ix in range(previews):
    filename = randomName(folder, 6, f"p{ix+1:02d}-", "-p.jpg")
    createFile(filename, f"fake preview file {'a' * ix}")

  for ix in range(thumbnails):
    filename = randomName(folder, 6, f"t{ix+1:02d}-", "-t.jpg")
    createFile(filename, f"fake thumbnail file {'b' * ix}")

  for ix in range(cjson):
    filename = os.path.join(folder, f"c{num+ix}.json")
    createFile(filename, f"fake cjson file {'c' * ix}")

  for ix in range(imageHtml):
    filename = os.path.join(folder, f"image-{num+ix}.html")
    createFile(filename, f"fake image html file {'d' * ix}")

  for ix in range(thumbnailHtml):
    filename = os.path.join(folder, f"thumbnails-{num+ix}.html")
    createFile(filename, f"fake thumbnail html file {'e' * ix}")

  for ix in range(others):
    filename = os.path.join(folder, f"other-{ix}.txt")
    createFile(filename, f"fake other file {'f' * ix}")

  return folder

def getTestImageInfoList(previews):
  """
  Return a list of preview image information for testing. The information is made up.
  """
  imageInfoList = []
  for ix, fileInfo in enumerate(previews):
    imageInfoList.append(ImageInfo(previewMinDim+ix, previewMinDim+ix, "JPEG"))
  return imageInfoList

class TestClients:
  def __init__(self):
    self.s3Client = getBotoClient('s3')

tc = None

def setUpModule():
  # Get the boto clients we test. This method is called once by the
  # test suite. The code is here to avoid a runtime error in the
  # shutdown phase.
  global tc
  tc = TestClients()

def tearDownModule():
  pass

class TestMaker(unittest.TestCase):
  def test_me(self):
    self.assertTrue(True)

  def test_FileInfo(self):
    fi = FileInfo("basename", isFile=True, size=0)
    eStr = "file        0 basename"
    gotExpected(str(fi), eStr)

    fi2 = FileInfo("name", isFile=False, size=1000)
    eStr2 = "-        1000 name"
    gotExpected(str(fi2), eStr2)

  def test_random62(self):
    r1 = random62(6)
    gotExpected(len(r1), 6)
    r2 = random62(10)
    gotExpected(len(r2), 10)

  def test_randomName(self):
    name = randomName("folder", 6, "prefix-", "-p.jpg")
    gotExpected(len(name), 26)
    assert name.startswith("folder/prefix-")
    assert name.endswith("-p.jpg")

  def test_createFile(self):
    folder = tempfile.mkdtemp(prefix="maker-")
    filename = os.path.join(folder, "test.txt")
    createFile(filename, "test contents")
    with open(filename, 'r', encoding='utf-8') as fh:
      contents = fh.read()
    gotExpected(contents, "test contents")
    shutil.rmtree(folder)

  def test_getStdImageName(self):
    gotExpected(getStdImageName(2, 3, "preview", "basename"), "c2-4-p.jpg")
    gotExpected(getStdImageName(23, 15, "preview", "basename"), "c23-16-p.jpg")
    gotExpected(getStdImageName(2, 3, "thumbnail", "basename"), "c2-4-t.jpg")
    gotExpected(getStdImageName(23, 15, "thumbnail", "basename"), "c23-16-t.jpg")
    gotExpected(getStdImageName(2, 3, "preview", "path"), "/images/c2/c2-4-p.jpg")
    gotExpected(getStdImageName(23, 15, "preview", "path"), "/images/c23/c23-16-p.jpg")
    gotExpected(getStdImageName(2, 3, "thumbnail", "path"), "/images/c2/c2-4-t.jpg")
    gotExpected(getStdImageName(23, 15, "thumbnail", "path"), "/images/c23/c23-16-t.jpg")

  def test_makeTestFolder(self):
    num = 4
    folder = makeTestFolder(num)
    assert os.path.exists(folder)
    # pv("folder", folder)
    fileInfoList = getFileInfoList(folder)
    # for ix, fileInfo in enumerate(fileInfoList):
    #   pv("fileInfo", str(fileInfo))
    # print("")
    ftg = FileTypeGroups(fileInfoList)
    shutil.rmtree(folder)

    gotExpected(len(ftg.previews), 8)
    gotExpected(len(ftg.thumbnails), 8)
    gotExpected(len(ftg.jsonFiles), 1)
    gotExpected(len(ftg.htmlFilesI), 1)
    gotExpected(len(ftg.htmlFilesT), 1)

    gotExpected(str(ftg.jsonFiles[0]),  "file       16 c4.json")
    gotExpected(str(ftg.htmlFilesI[0]), "file       21 image-4.html")
    gotExpected(str(ftg.htmlFilesT[0]), "file       25 thumbnails-4.html")

    for ix, fileInfo in enumerate(ftg.previews):
      # fileInfo: file       18 p01-kw34Ml-p.jpg
      gotExpected(len(str(fileInfo)), 30)
      gotExpected(str(fileInfo)[0:18], f"file       {18+ix} p{ix+1:02d}-")
      gotExpected(str(fileInfo)[-6:], "-p.jpg")

    for ix, fileInfo in enumerate(ftg.thumbnails):
      # fileInfo: file       20 t01-0PeLgR-t.jpg
      gotExpected(len(str(fileInfo)), 30)
      gotExpected(str(fileInfo)[0:18], f"file       {20+ix} t{ix+1:02d}-")
      gotExpected(str(fileInfo)[-6:], "-t.jpg")

  def test_makeTestFolderAll(self):
    folder = makeTestFolder(4, previews=1, thumbnails=2, cjson=3,
      imageHtml=4, thumbnailHtml=5, others=6)
    assert os.path.exists(folder)
    # pv("folder", folder)
    fileInfoList = getFileInfoList(folder)
    ftg = FileTypeGroups(fileInfoList)
    shutil.rmtree(folder)
    gotExpected(len(ftg.previews), 1)
    gotExpected(len(ftg.thumbnails), 2)
    gotExpected(len(ftg.jsonFiles), 3)
    gotExpected(len(ftg.htmlFilesI), 4)
    gotExpected(len(ftg.htmlFilesT), 5)
    gotExpected(len(ftg.other), 6)

  def test_dim(self):
    gotExpected(thumbnailDim, 480)
    gotExpected(previewMinDim, 933)

  def test_ImageFile(self):
    previewName = "dist/images/c1/c1-1-p.jpg"
    pii = ImageInfo.fromFile(previewName)
    gotExpected(pii.kind, "JPEG")
    gotExpected(pii.width, 3024)
    gotExpected(pii.height, 4032)
    gotExpected(str(pii), "JPEG (3024 x 4032)")

    thumbnailName = "dist/images/c1/c1-1-t.jpg"
    tii = ImageInfo.fromFile(thumbnailName)
    gotExpected(tii.kind, "JPEG")
    gotExpected(tii.width, 480)
    gotExpected(tii.height, 480)
    gotExpected(str(tii), "JPEG (480 x 480)")

  def test_ImageFileMissing(self):
    try:
      ImageInfo.fromFile("missing")
      assert False, "Unexpectedly passed"
    except MakerException as ex:
      gotExpected(str(ex), "Error: unable to open the image file: missing")

  def test_getImageInfoList(self):
    folder = "dist/images/c1"
    fileInfoList = getFileInfoList(folder)
    ftg = FileTypeGroups(fileInfoList)
    piiList = getImageInfoList(folder, ftg.previews, previews=True)
    gotExpected(len(piiList), 8)
    getImageInfoList(folder, ftg.thumbnails, previews=False)
    # for ix, pii in enumerate(piiList):
    #  pv("pii", pii)
    gotExpected(len(piiList), 8)

  def test_readDbPrefixes(self):
    if not internet:
      return
    awsSettings = getAwsSettings()
    settings = awsSettings['settings']
    bucket_name = settings['bucket_name']
    prefixes = readDbPrefixes(tc.s3Client, bucket_name)
    assert len(prefixes) > 0
    # for prefix in prefixes:
    #   pv("prefix", prefix)
    # prefix: db/c3
    # prefix: db/published-2
    working = 0
    published = 0
    for prefix in prefixes:
      if prefix.startswith("db/c"):
        working += 1
      elif prefix.startswith("db/published-"):
        published += 1
    gotExpected(published, 1)

  def test_nextDbNum(prefixes):
    if not internet:
      return
    gotExpected(nextDbNum(["db/published-2"]), 3)
    gotExpected(nextDbNum(["db/published-2", "db/c3"]), 4)
    gotExpected(nextDbNum(["db/published-2", "db/c1", "db/c2"]), 3)
    gotExpected(nextDbNum(["db/published-2", "db/c3", "db/c1"]), 4)
    gotExpected(nextDbNum(["db/published-2", "db/c3", "db/c4"]), 5)

  def test_makeDbPrefixC(self):
    if not internet:
      return
    prefix, content = makeDbPrefix('c', 4)
    gotExpected(prefix, "db/c4")
    gotExpected(content, "collection under development")

  def test_makeDbPrefixPublished(self):
    if not internet:
      return
    prefix, content = makeDbPrefix('published', 4)
    gotExpected(prefix, "db/published-4")
    gotExpected(content, "published collection")

  def test_writeDbPrefix(self):
    # Test writing a db prefix.
    if not internet:
      return
    awsSettings = getAwsSettings()
    settings = awsSettings['settings']
    bucket_name = settings['bucket_name']

    prefixes1 = readDbPrefixes(tc.s3Client, bucket_name)
    #pv("prefixes1", prefixes1)
    num = nextDbNum(prefixes1)

    writeDbPrefix(tc.s3Client, bucket_name, "c", num)

    prefixes2 = readDbPrefixes(tc.s3Client, bucket_name)
    num2 = nextDbNum(prefixes2)
    gotExpected(num2, num + 1)

    deleteDbPrefix(tc.s3Client, bucket_name, "c", num)
    prefixes3 = readDbPrefixes(tc.s3Client, bucket_name)
    #pv("prefixes3", prefixes3)
    num3 = nextDbNum(prefixes3)
    gotExpected(num3, num)
    gotExpected(prefixes3, prefixes1)

  def test_dbPrefixes(self):
    if not internet:
      return

    # If you want to test, comment out the return an set e_num
    # correctly.
    return

    e_num = 4

    # Test getting and setting the db prefixes.
    num = getNextCollectionNum(tc.s3Client)
    gotExpected(num, e_num)

    writeDbPrefix(tc.s3Client, "sflennikco", "c", e_num)
    num = getNextCollectionNum(tc.s3Client)
    gotExpected(num, e_num+1)

    writeDbPrefix(tc.s3Client, "sflennikco", "c", e_num+1)
    num = getNextCollectionNum(tc.s3Client)
    gotExpected(num, e_num+2)

    deleteDbPrefix(tc.s3Client, "sflennikco", "c", e_num)
    deleteDbPrefix(tc.s3Client, "sflennikco", "c", e_num+1)
    deleteDbPrefix(tc.s3Client, "sflennikco", "c", e_num+2)

  def test_getFileInfoList(self):
    fileInfoList = getFileInfoList("dist")
    self.assertTrue(len(fileInfoList) > 0)
    found = 0
    for fileInfo in fileInfoList:
      # pv('fileInfo', fileInfo)
      if fileInfo.basename == "index.html":
        found += 1
      elif fileInfo.basename == "images":
        found += 1
    gotExpected(found, 2)

  def test_getImageInfo(self):
    previewFile = "/home/coder/collections/dist/images/c1/c1-1-p.jpg"
    imageInfo = ImageInfo.fromFile(previewFile)
    gotExpected(imageInfo.kind, "JPEG")
    gotExpected(imageInfo.width, 3024)
    gotExpected(imageInfo.height, 4032)

    thumbnailFile = "/home/coder/collections/dist/images/c1/c1-1-t.jpg"
    info = ImageInfo.fromFile(thumbnailFile)
    # pv('thumbnailImageInfo', thumbnailImageInfo)
    gotExpected(info.kind, "JPEG")
    gotExpected(info.width, 480)
    gotExpected(info.height, 480)

  def test_getImageInfoNoFile(self):
    # Test with missing file.
    testGetImageInfoError("missing", "Error: unable to open the image file: missing")

  def test_getImageInfoNotImage(self):
    # Test with non-image file
    htmlFile = "dist/index.html"
    eMsg = "Error: unable to open the image file: dist/index.html"
    testGetImageInfoError(htmlFile, eMsg)

  def test_validateFolder(self):
    c1 = "/home/coder/collections/dist/images/c1"
    fileInfoList = getFileInfoList(c1)
    ftg = FileTypeGroups(fileInfoList)
    validateCollectionFolder(1, ftg)

  def test_validateFolderUnmatched(self):
    eMsg = "Error: mismatch: 8 previews != 9 thumbnails."
    testValidateFolderError(4, previews=8, thumbnails=9, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolder7(self):
    eMsg = "Error: 7 images, you need at least 8."
    testValidateFolderError(4, previews=7, thumbnails=7, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolder21(self):
    eMsg = "Error: 21 images, you are limited to 20."
    testValidateFolderError(4, previews=21, thumbnails=21, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderExtra(self):
    eMsg = "Error: there are 2 extra files in the folder, first: other-0.txt"
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg, others=2)

  def test_validateFolderNoPreviews(self):
    eMsg = "Error: no previews files that end in -p.jpg."
    testValidateFolderError(4, previews=0, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderNoThumbs(self):
    eMsg = "Error: no thumbnails files that end in -t.jpg."
    testValidateFolderError(4, previews=8, thumbnails=0, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderCjson(self):
    eMsg = "Error: 2 json files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=2,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderCjson1(self):
    eMsg = "Error: 2 json files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=2,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderPreHtml(self):
    eMsg = "Error: 3 image html files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=1,
      imageHtml=3, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderThumbHtml(self):
    eMsg = "Error: 2 thumbnails html files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=1,
      imageHtml=1, thumbnailHtml=2, eMsg=eMsg)

  def test_createCollectionCinfo(self):
    num = 3
    try:
      folder = makeTestFolder(num, previews=8, thumbnails=8,
        cjson=0, imageHtml=0, thumbnailHtml=0, others=0)
      fileInfoList = getFileInfoList(folder)

      ftg = FileTypeGroups(fileInfoList)
      validateCollectionFolder(num, ftg)

      previewImageInfoList = getTestImageInfoList(ftg.previews)

      cinfo = createCollectionCinfo(num, ftg, previewImageInfoList)
      cjson = json.dumps(cinfo, indent=2)
      # print(cjson)

      gotExpected(cinfo['title'], "")
      gotExpected(cinfo['description'], "")
      gotExpected(cinfo['collection'], num)
      gotExpected(cinfo['width'], thumbnailDim)
      gotExpected(cinfo['height'], thumbnailDim)
      # gotExpected(len(cinfo['order']), 0)
      # gotExpected(len(cinfo['images']), 8)
      for ix, image in enumerate(cinfo['images']):
        #print(json.dumps(image, indent=2))
        expected = f"""{{
  "title": "",
  "description": "",
  "url": "{getStdImageName(num, ix, "preview", "path")}",
  "width": {933+ix},
  "height": {933+ix},
  "size": {18+ix},
  "thumbnail": "{getStdImageName(num, ix, "thumbnail", "path")}",
  "sizet": {20+ix}
}}"""
        gotExpected(json.dumps(image, indent=2), expected)

      renameFiles(num, folder, ftg)

      fileInfoList = getFileInfoList(folder)

      ftg = FileTypeGroups(fileInfoList)

      for ix, fileInfo in enumerate(ftg.previews):
        # pv('fileInfo', fileInfo)
        gotExpected(fileInfo.basename, getStdImageName(num, ix, "preview", "basename"))
      for ix, fileInfo in enumerate(ftg.thumbnails):
        # pv('fileInfo', fileInfo)
        gotExpected(fileInfo.basename, getStdImageName(num, ix, "thumbnail", "basename"))

      validateCollectionFolder(num, ftg)

    finally:
      shutil.rmtree(folder)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
