#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script makes a new collection.

See collection-maker.md for a guide to making collections.

"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
from datetime import datetime
from collections import namedtuple
import json
import subprocess
import sys
import textwrap

from PIL import Image

workingDir='/home/coder/collections'

# Location where the new list of image files exists.
tmpFolder=f'{workingDir}/tmp/working'

class MakerException(Exception):
  """ An exception we plan for. """
  pass

def createNew(num):
  """
  Create a new local collection folder from a folder of images.
  """
  sourceFolder = f"{tmpFolder}/c{num}"
  if not os.path.exists(sourceFolder):
    raise MakerException(f"Missing the collection folder: {sourceFolder}")

  localDestFolder = f"images/c{num}"
  if not os.path.exists(localDestFolder):
    raise MakerException(f"The local collection folder already exists: {localDestFolder}")

  # Get names and info of all the files in the sourceFolder.
  # Validate the files work in a collection.
  fileInfoList = getFileInfoList(sourceFolder)
  validateFolder(num, fileInfoList)

  # todo: verify that the collection is the next available collection. It checks the
  #  /db prefix files.
  # reserve the num by writing the db prefix


  # Rename the images files to their standard name.
  fileInfoList = getFileInfoList(sourceFolder)
  renameFiles(fileInfoList)
  cjson = validateFolder(num, fileInfoList)

  # Write the cjson file if it doesn't already exist.
  cjsonFilename = os.path.join(sourceFolder, f"c{num}.json")
  if not os.path.exists(asdf):
    with open(cjsonFilename, "w") as fh:
      fh.write(cjson)

  # Move the folder to the local images folder.
  os.rename(sourceFolder, localDestFolder)

  print(f"Created a new local collection: {localDestFolder}")

class FileInfo(object):
  def __init__(self, fullPath, isFile, size, modDate):
    self.fullPath = fullPath
    self.isFile = isFile
    self.size = size
    self.modDate = modDate
  def __str__(self):
    isFileStr = "file" if self.isFile else "-"
    modified_time = datetime.utcfromtimestamp(self.modDate).strftime('%Y-%m-%d %H:%M:%S')
    return f"{isFileStr:4} {self.size:8} {modified_time:19} {self.fullPath}"

def getFileInfoList(folder):
  """
  Return information about each file in a folder.
  """
  fileInfoList = []
  fullPath = os.path.abspath(folder)
  for entry in os.scandir(fullPath):
    stats = entry.stat()
    fileInfo = FileInfo(
      f"{fullPath}/{entry.name}",
      entry.is_file(),
      stats.st_size,
      stats.st_mtime
    )
    fileInfoList.append(fileInfo)
  return fileInfoList

def validateFolder(num, fileInfoList):
  """
  Validate that the given files works as a collection and return
  the cjson. num is the collection number
  """

  previews = []
  thumbnails = []
  jsonFiles = []
  htmlFiles = []
  other = []
  for fileInfo in fileInfoList:
    filename = fileInfo.fullPath
    # pv("filename", filename)

    if filename.endswith("-p.jpg"):
      previews.append(filename)
    elif filename.endswith("-t.jpg"):
      thumbnails.append(filename)
    elif filename.endswith(".json"):
      jsonFiles.append(filename)
    elif filename.endswith(".html"):
      htmlFiles.append(filename)
    else:
      other.append(filename)

  if len(previews) == 0:
    raise MakerException(f"Error: no previews files that end in -p.jpg.")
  if len(thumbnails) == 0:
    raise MakerException(f"Error: no thumbnails files that end in -t.jpg.")

  if len(previews) != len(thumbnails):
    raise MakerException(f"Error: the number of thumbnails ({len(thumbnails)}) and previews ({len(previews)}) must match.")

  if len(thumbnails) < 8:
    raise MakerException(f"Error: not enough images, you need at least 8, found: {len(thumbnails)}.")
  if len(thumbnails) > 20:
    raise MakerException(f"Error: too many images, you are limited to 20, found: {len(thumbnails)}.")
  if len(jsonFiles) == 1:
    basename = os.path.basename(jsonFiles[0])
    if basename != f"c{num}.json":
      raise MakerException(f"Error: invalid cjson name for this collection: {basename}")

  if len(htmlFiles) > 0:
    for filename in htmlFiles:
      basename = os.path.basename(filename)
      e_images_page = f"image-{num}.html"
      e_thumbnails_page = f"thumbnails-{num}.html"
      if basename not in [e_images_page, e_thumbnails_page]:
        raise MakerException(f"Error: invalid html name for this collection: {basename}")

  if len(jsonFiles) > 1:
    raise MakerException("Error: more than one cjson file")

  if len(htmlFiles) > 2:
    raise MakerException("Error: more than two html files")

  if len(other):
    raise MakerException(f"Error: there are {len(other)} extra files in the folder: {other[0]}")

  images = []

  for ix, filename in enumerate(previews):
    thumbnail = thumbnails[ix]

    collectionImage = {}
    collectionImage['title'] = ""
    collectionImage['description'] = ""

    ii = getImageInfo(filename)
    if ii.width < 933 or ii.height < 933:
      got = f"{filename}: ({ii.width} x {ii.height})"
      raise MakerException(f"Error: preview must be greater than or equal to 933, found: {got}")
    if ii.kind != "JPEG":
      got = f"{filename}: {ii.kind}"
      raise MakerException(f"Error: preview must be a jpg, found: {got}")

    collectionImage['url'] = f"/images/c{num}/c{num}-{ix+1}-p.jpg"
    collectionImage['width'] = ii.width
    collectionImage['height'] = ii.height
    collectionImage['size'] = ii.fileSize

    ti = getImageInfo(thumbnail)
    if ti.width != 480 or ti.height != 480:
      got = f"{thumbnail}: ({ti.width} x {ti.height})"
      raise MakerException(f"Error: thumbnail must by 480 by 480, found: {got}")
    if ti.kind != "JPEG":
      got = f"{thumbnail}: {ti.kind}"
      raise MakerException(f"Error: thumbnail must be a jpg, found: {ti.kind}")

    collectionImage['thumbnail'] = f"/images/c{num}/c{num}-{ix+1}-t.jpg"
    collectionImage['sizet'] = ti.fileSize
    images.append(collectionImage)

  # Create the cjson.
  collection = {
    "title": "",
    "description": "",
    "collection": num,
    "width": 480,
    "height": 480,
    "imagePageUrl": f"/images/c{num}/image-{num}.html",
    "thumbnailsPageUrl": f"/images/c{num}/thumbnails-{num}.html",
    "images": images,
    "usedImages": [],
  }
  return json.dumps(collection, indent=2)

class ImageInfo(object):
  def __init__(self, width, height, kind, fileSize):
    self.width = width
    self.height = height
    self.kind = kind
    self.fileSize = fileSize
  def __str__(self):
    return f"{self.kind} ({self.width} x {self.height}) {self.fileSize}"

def getImageInfo(filename, fileSize=None):
  """
  Return the image information of a file.
  """
  if fileSize is None:
    try:
      fileSize = os.path.getsize(filename)
    except FileNotFoundError:
      raise MakerException(f"Error: the file doesn't exist: {filename}")
  else:
    fileSize = fileSize

  try:
    with Image.open(filename) as img:
      width, height = img.size
  except Exception as ex:
    raise MakerException(f"Error: unable to open the image file: {str(ex)}")

  return ImageInfo(width=width, height=height, kind=img.format, fileSize=fileSize)

def process(args):
  """
  """
  if args.createNew:
    createNew(args.createNew)
  else:
    showHelp()

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test = True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")
  parser.add_argument("-c", "--createNew", type=int, metavar="collectionNum",
    help="create a new local collection folder from a directory of images")

  args = parser.parse_args(sys.argv[1:])
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except MakerException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success


def testVerifyNamesError(filenames, eMessage):
  """
  Test verifyNames errors, pass in the expected error message.
  """
  previews, thumbnails, other, jsonFiles, htmlFiles = previewsAndThumbnails(filenames)

  try:
    verifyNames(previews, thumbnails, other)
    assert False, "Unexpectedly passed"
  except MakerException as ex:
    gotExpected(str(ex), eMessage)
    return # passed
  assert False, "Got an unexpected exception."

def testGetCollectionImagesError(previews, thumbnails, eMessage):
  """
  Test getCollectionImages errors, pass in the expected error message.
  """
  try:
    getCollectionImages(1, previews, thumbnails)
    assert False, "Unexpectedly passed"
  except MakerException as ex:
    gotExpected(str(ex), eMessage)
    return # passed
  assert False, "Got an unexpected exception."

def gotExpected(got, expected):
  if got != expected:
    msg = f"""
     got: {got}
expected: {expected}
"""
    assert False, msg

def pv(name, value):
  print(f"{name}: {value}")

def fail(msg):
  assert 0 == 1, message

def testGetImageInfoError(filename, eMsg):
  """
  Test getImageInfo errors, pass in the expected error message.
  """
  try:
    getImageInfo(filename)
    fail("Unexpectedly passed")
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")



class TestMaker(unittest.TestCase):

  def test_getFileInfoList(self):
    fileInfoList = getFileInfoList("dist")
    self.assertTrue(len(fileInfoList) > 0)
    for fileInfo in fileInfoList:
      # pv('fileInfo', fileInfo)
      self.assertTrue(fileInfo.fullPath.startswith("/home/coder/collections/dist/"))

  def test_getImageInfo(self):
    fileInfoList = getFileInfoList("dist/images/c1")
    # for fileInfo in fileInfoList:
    #   pv('fileInfo', fileInfo)
    previewFile = "/home/coder/collections/dist/images/c1/c1-1-p.jpg"
    imageInfo = getImageInfo(previewFile)
    gotExpected(imageInfo.kind, "JPEG")
    gotExpected(imageInfo.width, 3024)
    gotExpected(imageInfo.height, 4032)
    gotExpected(imageInfo.fileSize, 2797506)

    thumbnailFile = "/home/coder/collections/dist/images/c1/c1-1-t.jpg"
    info = getImageInfo(thumbnailFile)
    # pv('thumbnailImageInfo', thumbnailImageInfo)
    gotExpected(info.kind, "JPEG")
    gotExpected(info.width, 480)
    gotExpected(info.height, 480)
    gotExpected(info.fileSize, 71810)

  def test_getImageInfoSize(self):
    # Test when you pass in a file size.
    previewFile = "/home/coder/collections/dist/images/c1/c1-1-p.jpg"
    imageInfo = getImageInfo(previewFile, 1234567)
    gotExpected(imageInfo.fileSize, 1234567)

  def test_getImageInfoNoFile(self):
    # Test with missing file.
    testGetImageInfoError("missing", "Error: the file doesn't exist: missing")

  def test_getImageInfoNotImage(self):
    # Test with non-image file
    htmlFile = "/home/coder/collections/dist/index.html"
    eMsg = "Error: unable to open the image file: cannot identify image file '/home/coder/collections/dist/index.html'"
    testGetImageInfoError(htmlFile, eMsg)

  def test_validateFolder(self):
    c1 = "/home/coder/collections/dist/images/c1"
    fileInfoList = getFileInfoList(c1)
    validateFolder(1, fileInfoList)

  def test_validateFolderTmp(self):
    c3 = "/home/coder/collections/tmp/c3"
    fileInfoList = getFileInfoList(c3)
    cjson = validateFolder(3, fileInfoList)
    # print(cjson)
    # todo: check cjson

  # test at least 8 images
  # test at most 20 images
  # verify the same number of previews and thumbnails
  # verify the number of images is even
  # test no extra files in the folder
  # test previews width and height are greater than 933
  # test that thumbnails are 480 by 480


if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
