#!/usr/bin/python3

# This is the help text shown with -h:

"""
This script makes a new collection.

See collection-maker.md for a guide to making collections.

"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

# Check that this script is run from the collections folder
cwd = os.getcwd()
if not cwd.endswith("collections"):
  print(f"""\
Run from the collections folder:
cd ~/collections
scripts/maker
""")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import urllib.parse
import tempfile
from datetime import datetime
from collections import namedtuple
import json
import subprocess
import sys
import textwrap
from boto_client import getBotoClient, getAwsSettings
import random
import string
import shutil
from PIL import Image

thumbnailDim = 480
previewMinDim = 933

workingDir='/home/coder/collections'

# Folder where the new collection folder exists.
tmpFolder=f'{workingDir}/tmp/working'

class MakerException(Exception):
  """ An exception we plan for. """
  pass

def createNew(num):
  """
  Create a new local collection folder from a folder of images.
  """
  assert int(num) > 0

  sourceFolder = os.path.join(workingDir, num)
  if not os.path.exists(sourceFolder):
    raise MakerException(f"Missing the collection folder: {sourceFolder}")

  nextNum = getNextCollectionNum()
  if num != nextNum:
    raise MakerException(f"Error: the collection number is not available, use: {nextNum}.")

  localDestFolder = f"images/c{num}"
  if not os.path.exists(localDestFolder):
    raise MakerException(f"The local collection folder already exists: {localDestFolder}")

  # Get names and info of all the files in the sourceFolder and
  # validate that they work in a collection.
  fileInfoList = getFileInfoList(sourceFolder)
  ftg = FileTypeGroups(fileInfoList)
  validateCollectionFolder(num, ftg)

  # Validate the image dimensions and return the preview image information.
  previewImageInfoList = getPreviewSizes(ftg)

  # Reserve the collection number for this collection.
  reserveCollectionNum(num)

  cinfo = createCollectionCinfo(num, ftg, previewImageInfoList)

  # Rename the images in the tmp folder to their standard names.
  renameFiles(sourceFolder, cinfo, ftg)

  # Write the cjson file in the tmp folder.
  cjsonFilename = os.path.join(sourceFolder, f"c{num}.json")
  with open(cjsonFilename, "w") as fh:
    fh.write(json.dumps(cinfo, indent=2))

  # Move the tmp folder to the local images folder.
  os.rename(sourceFolder, localDestFolder)

  print(f"Reserved collection {num}.")
  print(f"Created a collection folder and moved it to: {localDestFolder}")

def getNextCollectionNum():
  """
  Return the next available collection number.
  """
  awsSettings = getAwsSettings()
  settings = awsSettings['settings']
  bucket_name = settings['bucket_name']
  s3Client = getBotoClient('s3')

  prefixes = readDbPrefixes(s3Client, bucket_name)

  num = nextDbNum(prefixes)
  return num

def readDbPrefixes(s3Client, bucket_name):
  """
  Read the prefixes that start with db/.
  """
  bucket_name = 'sflennikco'
  prefix = "db/"
  response = s3Client.list_objects_v2(Bucket=bucket_name, Prefix=prefix)
  prefixes = []
  if 'Contents' in response:
    for obj in response['Contents']:
      prefixes.append(obj['Key'])
  return prefixes

def nextDbNum(prefixes):
  """
  Return the next collection number given a list of db prefixes.
  """
  num = 0
  for prefix in prefixes:
    if prefix.startswith('c'):
      pnum = int(prefix[1:])
    elif prefix.startswith('published-'):
      pnum = int(prefix[10:])
    else:
      continue
    if pnum > num:
      num = pnum
  nextNum = num + 1
  return nextNum

def reserveCollectionNum(num):
  """
  Reserve the collection number.
  """
  # Determine the next from the current list the db prefix items.

  awsSettings = getAwsSettings()
  settings = awsSettings['settings']
  bucket_name = settings['bucket_name']
  s3Client = getBotoClient('s3')

  prefixes = readDbPrefixes(s3Client, bucket_name)

  nextNum = nextDbNum(prefixes)
  if nextNum != num:
    raise MakerException(f"Error: the collection number is not available, use: {nextNum}.")

  writeDbPrefix(s3client, bucket_name, "c", nextNum)
  return nextNum

def makeDbPrefix(kind, num):
  assert int(num) > 0
  if kind == "c":
    prefix = f"db/c{num}"
    content = 'collection under development'
  elif kind == "published":
    prefix = f"db/published-{num}"
    content = 'published collection'
  else:
    raise MakerException(f"Error: invalid prefix kind.")
  return prefix, content

def writeDbPrefix(s3Client, bucket_name, kind, num):
  """
  Write the db prefix. kind is "c" or "published" and num is the
  collection number.
  """
  prefix, content = makeDbPrefix(kind, num)
  s3Client.put_object(Bucket=bucket_name, Key=prefix, Body=content)

def deleteDbPrefix(s3Client, bucket_name, kind, num):
  """
  Remove a db prefix.  kind is "c" or "published" and num is the
  collection number.
  """
  prefix, content = makeDbPrefix(kind, num)

  s3Client.delete_object(Bucket=bucket_name, Key=prefix)

def getPreviewSizes(ftg):
  """
  Return the preview image information as a list of ImageInfo objects.
  If the image is the wrong size or not a jpg, raise an exception.
  """

  previewImageInfoList = []
  for ix, previewFileInfo in enumerate(ftg.previews):
    thumbnailFileInfo = ftg.thumbnails[ix]
    tii = ImageInfo(thumbnailFileInfo.basename, thumbnailFileInfo.size)
    if tii.width != thumbnailDim or tii.height != thumbnailDim:
      raise MakerException(
        f"""\
Error: thumbnail must be square ({thumbnailDim} x {thumbnailDim}).
file: ({tii.width} x {tii.height}) {tii.fullPath}
"""
      )
    if tii.kind != "JPEG":
      got = f"{thumbnailFileInfo}: {tii.kind}"
      raise MakerException(f"""\
Error: thumbnail must be a jpg.
file: {tii.fullPath}
""")

    previewFile = previewFileInfo.fullPath
    pii = ImageInfo(previewFile, previewFileInfo.size)

    if pii.width < previewMinDim or pii.height < previewMinDim:
      raise MakerException(
        f"""\
Error: preview width and hight must greater than or equal to {previewMinDim}.
file: ({tii.width} x {tii.height}) {tii.fullPath}
"""
      )
      got = f"{previewFile}: ({pii.width} x {pii.height})"
      raise MakerException(f"Error: preview must be greater than or equal to {pMinWidth}, found: {got}")
    if pii.kind != "JPEG":
      raise MakerException(f"""\
Error: preview must be a jpg.
file: {pii.fullPath}
""")

    previewImageInfoList.append(pii)

def renameFiles(folder, cinfo, ftg):
  """
  Rename the image files in the given folder to use the standard
  collection number naming.
  """
  parentFolder = os.path.dirname(folder)
  assert parentFolder == tmpFolder
  assert len(ftg.previews) == len(cinfo['images'])
  assert len(ftg.thumbnails) == len(cinfo['images'])

  for ix, image in enumerate(cinfo['images']):
    previewName = ftg.previews[ix].fullPath
    thumbnailName = ftg.thumbnails[ix].fullPath

    stdPreviewName = os.path.join(folder, f"c{num}-{ix+1}-p.jpg")
    stdThumbnailName = os.path.join(folder, f"c{num}-{ix+1}-t.jpg")

    os.rename(previewName, stdPreviewName)
    os.rename(thumbnailName, stdThumbnailName)

class FileInfo(object):
  def __init__(self, basename, isFile, size, modDate):
    self.basename = basename
    self.isFile = isFile
    self.size = size
    self.modDate = modDate
  def __str__(self):
    isFileStr = "file" if self.isFile else "-"
    dt = datetime.fromtimestamp(self.modDate)
    dateTimeStr = dt.strftime('%Y-%m-%d %H:%M:%S')
    return f"{isFileStr:4} {self.size:8} {dateTimeStr:19} {self.fullPath}"

def getFileInfoList(folder):
  """
  Return information about each file in a folder.
  """
  fileInfoList = []
  for entry in os.scandir(folder):
    stats = entry.stat()
    fileInfo = FileInfo(
      entry.name,
      entry.is_file(),
      stats.st_size,
      stats.st_mtime
    )
    fileInfoList.append(fileInfo)
  return fileInfoList

class FileTypeGroups(object):
  """
  Holds the file information for a collection folder.
  """
  def __init__(self, fileInfoList):
    self.previews = []
    self.thumbnails = []
    self.jsonFiles = []
    self.htmlFiles = []
    self.other = []
    for fileInfo in fileInfoList:
      filename = os.path.basename(fileInfo.fullPath)
      if filename.endswith("-p.jpg"):
        self.previews.append(fileInfo)
      elif filename.endswith("-t.jpg"):
        self.thumbnails.append(fileInfo)
      elif filename.endswith(".json"):
        self.jsonFiles.append(fileInfo)
      elif filename.endswith(".html"):
        self.htmlFiles.append(fileInfo)
      else:
        self.other.append(fileInfo)

def validateCollectionFolder(num, ftg):
  """
  Validate that the given files work as a collection. Num is the
  collection number. No files are read.
  """

  if len(ftg.previews) == 0:
    raise MakerException(f"Error: no previews files that end in -p.jpg.")
  if len(ftg.thumbnails) == 0:
    raise MakerException(f"Error: no thumbnails files that end in -t.jpg.")

  if len(ftg.previews) != len(ftg.thumbnails):
    raise MakerException(f"Error: the number of thumbnails ({len(thumbnails)}) and previews ({len(previews)}) must match.")

  if len(ftg.thumbnails) < 8:
    raise MakerException(f"Error: not enough images, you need at least 8, found: {len(thumbnails)}.")
  if len(ftg.thumbnails) > 20:
    raise MakerException(f"Error: too many images, you are limited to 20, found: {len(thumbnails)}.")
  if len(ftg.jsonFiles) == 1:
    basename = os.path.basename(ftg.jsonFiles[0])
    if basename != f"c{num}.json":
      raise MakerException(f"Error: invalid cjson name for this collection: {basename}")

  if len(ftg.htmlFiles) > 0:
    for filename in ftg.htmlFiles:
      basename = os.path.basename(filename)
      e_images_page = f"image-{num}.html"
      e_thumbnails_page = f"thumbnails-{num}.html"
      if basename not in [e_images_page, e_thumbnails_page]:
        raise MakerException(f"Error: invalid html name for this collection: {basename}")

  if len(ftg.jsonFiles) > 1:
    raise MakerException("Error: more than one cjson file")

  if len(ftg.htmlFiles) > 2:
    raise MakerException("Error: more than two html files")

  if len(ftg.other):
    raise MakerException(f"Error: there are {len(other)} extra files in the folder: {other[0]}")

def createCollectionCinfo(num, ftg, previewImageInfoList):
  """
  Create the collection info (cinfo) for the given collection number
  """
  assert len(ftg.previews) == len(ftg.thumbnails)
  images = []

  for ix, fileInfo in enumerate(ftg.previews):
    thumbnailFileInfo = ftg.thumbnails[ix]
    previewImageInfo = previewImageInfoList[ix]

    collectionImage = {}
    collectionImage['title'] = ""
    collectionImage['description'] = ""

    collectionImage['url'] = f"/images/c{num}/c{num}-{ix+1}-p.jpg"
    collectionImage['width'] = previewImageInfo.width
    collectionImage['height'] = previewImageInfo.height
    collectionImage['size'] = fileInfo.size

    collectionImage['thumbnail'] = f"/images/c{num}/c{num}-{ix+1}-t.jpg"
    collectionImage['sizet'] = thumbnailFileInfo.fileSize
    images.append(collectionImage)

  # Create the collection info (cinfo).
  cinfo = {
    "title": "",
    "description": "",
    "collection": num,
    "width": thumbnailDim,
    "height": thumbnailDim,
    "imagePageUrl": f"/images/c{num}/image-{num}.html",
    "thumbnailsPageUrl": f"/images/c{num}/thumbnails-{num}.html",
    "images": images,
    "usedImages": [],
  }
  return cinfo

class ImageInfo(object):
  """
  Holds the information for an image file.
  """
  def __init__(filename, fileSize):
    assert int(fileSize) > 0

    try:
      with Image.open(filename) as img:
        width, height = img.size
    except Exception as ex:
      raise MakerException(f"Error: unable to open the image file: {str(ex)}")
    self.width = width
    self.height = height
    self.kind = img.format
    self.fileSize = fileSize

  def __str__(self):
    return f"{self.kind} ({self.width} x {self.height}) {self.fileSize}"

def process(args):
  """
  """
  if args.createNew:
    createNew(num)

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test=True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="run internal unit tests. Use alone to run all tests.")
  parser.add_argument("-c", "--createNew", type=int, metavar="collectionNum",
    help="create a new local collection folder from a directory of images")

  args = parser.parse_args(sys.argv[1:])
  if not args.createNew and not args.test:
    # When there are no arguments provided, show the help information.
    parser.print_help()
    sys.exit(1)
  return args

def signalHandler(sig, frame):
  """ Handle ctrl-C """
  sys.exit(1)

def main(args):
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except MakerException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

# Test code:

def testVerifyNamesError(filenames, eMessage):
  """
  Test verifyNames errors, pass in the expected error message.
  """

  previews, thumbnails, other, jsonFiles, htmlFiles = previewsAndThumbnails(filenames)

  try:
    verifyNames(previews, thumbnails, other)
    assert False, "Unexpectedly passed"
  except MakerException as ex:
    gotExpected(str(ex), eMessage)
    return # passed
  assert False, "Got an unexpected exception."

def testGetCollectionImagesError(previews, thumbnails, eMessage):
  """
  Test getCollectionImages errors, pass in the expected error message.
  """
  try:
    getCollectionImages(1, previews, thumbnails)
    assert False, "Unexpectedly passed"
  except MakerException as ex:
    gotExpected(str(ex), eMessage)
    return # passed
  assert False, "Got an unexpected exception."

def gotExpected(got, expected):
  if got != expected:
    msg = f"""
     got: {got}
expected: {expected}
"""
    assert False, msg

def pv(name, value):
  print(f"{name}: {value}")

def fail(msg):
  assert 0 == 1, message

def testGetImageInfoError(filename, eMsg):
  """
  Test getImageInfo errors, pass in the expected error message.
  """
  try:
    getImageInfo(filename)
    fail("Unexpectedly passed")
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")

def testValidateFolderError(num, previews=8, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=""):
  try:
    folder = makeTestFolder(num, previews=previews, thumbnails=thumbnails,
      cjson=cjson, imageHtml=imageHtml, thumbnailHtml=thumbnailHtml)
    fileInfoList = getFileInfoList(folder)
  finally:
    shutil.rmtree(folder)

  try:
    validateFolder(num, fileInfoList, pMinWidth=100, pThumbnailWidth=50, readImage=False)
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")

def randomName(folder, k=6, prefix="", postfix=""):
  """
  Return a random name in the given folder with the
  given prefix and postfix.
  """
  randomPart = random62(k)
  return os.path.join(folder, f"{prefix}{randomPart}{postfix}")

def random62(k):
  """
  Return a random base 62 number of the given length.
  """
  characters = string.ascii_letters + string.digits
  return ''.join(random.choices(characters, k=k))

def createFile(filename, contents):
  """ Create a new file with the given contents. """
  with open(filename, 'w+', encoding='utf-8') as fh:
    fh.write(contents)

def makeTestFolder(num, previews=8, thumbnails=8, cjson=1,
  imageHtml=1, thumbnailHtml=1):
  """
  Make a collection folder in the temp dir for testing. Return the
  folder name.  When done with the folder delete it with:
  shutil.rmtree(folder)
  """

  # Create a temp folder and fill it with the specified number of fake
  # small files.
  folder = tempfile.mkdtemp(prefix="maker-")
  for ix in range(previews):
    filename = randomName(folder, 6, "pre-", "-p.jpg")
    createFile(filename, "fake preview file")

  for ix in range(thumbnails):
    filename = randomName(folder, 6, "thumb-", "-t.jpg")
    createFile(filename, "fake thumbnail file")

  if cjson:
    filename = os.path.join(folder, f"c{num}.json")
    createFile(filename, "fake cjson file")

  if imageHtml:
    filename = os.path.join(folder, f"image-{num}.html")
    createFile(filename, "fake image html file")

  if thumbnailHtml:
    filename = os.path.join(folder, f"thumbnails-{num}.html")
    createFile(filename, "fake thumbnail html file")

  return folder

class TestClients:
  def __init__(self):
    self.s3Client = getBotoClient('s3')

tc = None

def setUpModule():
  # Get the boto clients we test. This method is called once by the
  # test suite. The code is here to avoid a runtime error in the
  # shutdown phase.
  global tc
  tc = TestClients()

def tearDownModule():
  pass

class TestMaker(unittest.TestCase):
  def test_readDbPrefixes(self):
    awsSettings = getAwsSettings()
    settings = awsSettings['settings']
    bucket_name = settings['bucket_name']
    prefixes = readDbPrefixes(tc.s3Client, bucket_name)
    assert len(prefixes) > 0
    # for prefix in prefixes:
    #   pv("prefix", prefix)
    # prefix: db/c3
    # prefix: db/published-2
    working = 0
    published = 0
    for prefix in prefixes:
      if prefix.startswith("db/c"):
        working += 1
      elif prefix.startswith("db/published-"):
        published += 1
    gotExpected(published, 1)

  def test_nextDbNum(prefixes):
    gotExpected(nextDbNum(["published-2"]), 3)
    gotExpected(nextDbNum(["published-2", "c3"]), 4)
    gotExpected(nextDbNum(["published-2", "c3", "c4"]), 5)

  def test_makeDbPrefixC(self):
    prefix, content = makeDbPrefix('c', 4)
    gotExpected(prefix, "db/c4")
    gotExpected(content, "collection under development")

  def test_makeDbPrefixPublished(self):
    prefix, content = makeDbPrefix('published', 4)
    gotExpected(prefix, "db/published-4")
    gotExpected(content, "published collection")

  # def test_roundTrip(self):
  #   awsSettings = getAwsSettings()
  #   settings = awsSettings['settings']
  #   bucket_name = settings['bucket_name']
  #   deleteDbPrefix(tc.s3Client, bucket_name, "c", 3)
  #   prefixes = readDbPrefixes(tc.s3Client, bucket_name)
  #   for prefix in prefixes:
  #     pv("prefix", prefix)
  #   writeDbPrefix(tc.s3Client, bucket_name, "c", 3)
  #   prefixes = readDbPrefixes(tc.s3Client, bucket_name)
  #   for prefix in prefixes:
  #     pv("prefix", prefix)

  def test_dbPrefixes(self):
    # Test getting and setting the db prefixes.
    num = getNextCollectionNum()
    gotExpected(num, 3)

    writeDbPrefix(tc.s3Client, "sflennikco", "c", 3)
    num = getNextCollectionNum()
    gotExpected(num, 4)

    writeDbPrefix(tc.s3Client, "sflennikco", "c", 4)
    num = getNextCollectionNum()
    gotExpected(num, 5)

    deleteDbPrefix(tc.s3Client, "sflennikco", "c", 3)
    deleteDbPrefix(tc.s3Client, "sflennikco", "c", 4)
    deleteDbPrefix(tc.s3Client, "sflennikco", "c", 5)

  def test_getFileInfoList(self):
    fileInfoList = getFileInfoList("dist")
    self.assertTrue(len(fileInfoList) > 0)
    for fileInfo in fileInfoList:
      # pv('fileInfo', fileInfo)
      self.assertTrue(fileInfo.fullPath.startswith("/home/coder/collections/dist/"))

  def test_getImageInfo(self):
    fileInfoList = getFileInfoList("dist/images/c1")
    # for fileInfo in fileInfoList:
    #   pv('fileInfo', fileInfo)
    previewFile = "/home/coder/collections/dist/images/c1/c1-1-p.jpg"
    imageInfo = getImageInfo(previewFile)
    gotExpected(imageInfo.kind, "JPEG")
    gotExpected(imageInfo.width, 3024)
    gotExpected(imageInfo.height, 4032)
    gotExpected(imageInfo.fileSize, 2797506)

    thumbnailFile = "/home/coder/collections/dist/images/c1/c1-1-t.jpg"
    info = getImageInfo(thumbnailFile)
    # pv('thumbnailImageInfo', thumbnailImageInfo)
    gotExpected(info.kind, "JPEG")
    gotExpected(info.width, 480)
    gotExpected(info.height, 480)
    gotExpected(info.fileSize, 71810)

  def test_getImageInfoSize(self):
    # Test when you pass in a file size.
    previewFile = "/home/coder/collections/dist/images/c1/c1-1-p.jpg"
    imageInfo = getImageInfo(previewFile, 1234567)
    gotExpected(imageInfo.fileSize, 1234567)

  def test_getImageInfoNoFile(self):
    # Test with missing file.
    testGetImageInfoError("missing", "Error: the file doesn't exist: missing")

  def test_getImageInfoNotImage(self):
    # Test with non-image file
    htmlFile = "/home/coder/collections/dist/index.html"
    eMsg = "Error: unable to open the image file: cannot identify image file '/home/coder/collections/dist/index.html'"
    testGetImageInfoError(htmlFile, eMsg)

  def test_validateFolder(self):
    c1 = "/home/coder/collections/dist/images/c1"
    fileInfoList = getFileInfoList(c1)
    validateFolder(1, fileInfoList)

  def test_validateFolderTmp(self):
    c3 = "/home/coder/collections/tmp/c3"
    fileInfoList = getFileInfoList(c3)
    cjson = validateFolder(3, fileInfoList)
    # print(cjson)
    # todo: check cjson

  def test_makeTestFolder(self):
    folder = makeTestFolder(4)
    assert os.path.exists(folder)
    # pv("folder", folder)
    fileInfoList = getFileInfoList(folder)
    filenames = []
    for fileInfo in fileInfoList:
      # pv("fileInfo", fileInfo)
      filenames.append(fileInfo.fullPath)
    filenames.sort()
    # for filename in filenames:
    #   pv("filename", filename)
    shutil.rmtree(folder)

  def test_validateFolderUnmatched(self):
    # number of previews doesn't match the number of thumbnails
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=None,
      imageHtml=None, thumbnailHtml=None, eMsg="")


  # test with 7 images
  # test at most 20 images
  # verify the same number of previews and thumbnails
  # verify the number of images is even
  # test no extra files in the folder
  # test previews width and height are greater than 933
  # test that thumbnails are 480 by 480


  # def test_renameFiles(self):
  #   c3 = "/home/coder/collections/tmp/c3"
  #   fileInfoList = getFileInfoList(c3)
  #   renameFiles(fileInfoList, 3)

  def test_randomName(self):
    name = randomName("folder", 6, "prefix-", "-p.jpg")
    pv("name", name)
    # folder/prefix-T223LT-p.jpg
    assert name.startswith("folder/prefix-")
    assert name.endswith("-p.jpg")
    gotExpected(len(name), 26)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
