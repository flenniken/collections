#!/usr/bin/python3

# This is the help text shown with -h:

"""
Make a new collection from a folder of images or create
a collections.json. See collection-maker.md for a guide to
making collections.
"""

import os

if not os.environ.get("coder_env"):
  print("Run from the Collection's docker environment.")
  exit(1)

# Check that this script is run from the collections folder
cwd = os.getcwd()
if not cwd.endswith("collections"):
  print(f"""\
Run from the collections folder:
cd ~/collections
scripts/maker
""")
  exit(1)

import sys
import argparse
import traceback
import sys
import signal
import unittest
import tempfile
import json
import sys
import textwrap
from boto_client import getBotoClient, getAwsSettings
import random
import string
import shutil
from PIL import Image, ImageOps

thumbnailDim = 480
previewMinDim = 933

workingDir='/home/coder/collections'

# Folder where the new collection folder exists.
tmpFolder=f'{workingDir}/tmp'

# True when the internet connection is working.
internet = True

class MakerException(Exception):
  """ An exception we plan for. """
  pass

class FileInfo(object):
  """
  File information important for a Collection.
  """
  def __init__(self, basename, isFile, size):
    self.basename = basename
    self.isFile = isFile
    self.size = size
  def __str__(self):
    isFileStr = "file" if self.isFile else "-"
    return f"{isFileStr:4} {self.size:8} {self.basename}"

def getFileInfoList(folder):
  """
  Return information about each file in a folder.
  """
  fileInfoList = []
  for entry in os.scandir(folder):
    stats = entry.stat()
    fileInfo = FileInfo(
      entry.name,
      entry.is_file(),
      stats.st_size,
    )
    fileInfoList.append(fileInfo)
  # Sort the fileInfoList by basename.
  fileInfoList.sort(key=lambda x: x.basename)
  return fileInfoList

class FileTypeGroups(object):
  """
  Holds the file information for a collection folder organized by
  the file type.
  """
  def __init__(self, fileInfoList):
    self.previews = []
    self.thumbnails = []
    self.jsonFiles = []
    self.htmlFilesI = []
    self.htmlFilesT = []
    self.other = []
    for fileInfo in fileInfoList:
      filename = os.path.basename(fileInfo.basename)
      if filename.endswith("-p.jpg"):
        self.previews.append(fileInfo)
      elif filename.endswith("-t.jpg"):
        self.thumbnails.append(fileInfo)
      elif filename.endswith(".json"):
        self.jsonFiles.append(fileInfo)
      elif filename.startswith("image-") and filename.endswith(".html"):
        self.htmlFilesI.append(fileInfo)
      elif filename.startswith("thumbnails-") and filename.endswith(".html"):
        self.htmlFilesT.append(fileInfo)
      else:
        self.other.append(fileInfo)

class ImageInfo(object):
  """
  Holds the information about an image file that is important for
  a collection.
  """
  def __init__(self, width, height, kind):
    self.width = width
    self.height = height
    self.kind = kind

  @classmethod
  def fromFile(cls, filename):
    """
    Create an ImageInfo object from a file.
    """
    try:
        with Image.open(filename) as img:
          kind = img.format

          # Apply EXIF orientation so width/height match what you see
          transposed_img = ImageOps.exif_transpose(img)
          width, height = transposed_img.size

          # Close the transposed image if it's a new object.
          if transposed_img is not img:
            transposed_img.close()

          return cls(width, height, kind)
    except Exception as ex:
        raise MakerException(f"Error: unable to open the image file: {filename}")

  def __str__(self):
    return f"{self.kind} ({self.width} x {self.height})"

def getImageInfoList(folder, fileInfoList, previews=True):
  """
  Return the image information as a list of ImageInfo objects.
  Previews is True when the fileInfoList is for previews, False
  when it is for thumbnails. If the image is the wrong size or
  not a jpg, raise an exception.
  """
  imageInfoList = []

  for ix, fileInfo in enumerate(fileInfoList):
    fullPath = os.path.join(folder, fileInfo.basename)
    ii = ImageInfo.fromFile(fullPath)
    if ii.kind != "JPEG":
      raise MakerException(f"""\
Error: image must be a jpg.
file: {ii.kind} ({ii.width} x {ii.height}) {fullPath}
""")
    if previews:
      if ii.width < previewMinDim or ii.height < previewMinDim:
        raise MakerException(
          f"""\
Error: preview width and height must greater than or equal to {previewMinDim}.
file: ({ii.width} x {ii.height}) {fileInfo.basename}
"""
        )
    else:
      if ii.width != thumbnailDim or ii.height != thumbnailDim:
        raise MakerException(
          f"""\
Error: thumbnail must be square ({thumbnailDim} x {thumbnailDim}).
file: ({ii.width} x {ii.height}) {fileInfo.basename}
"""
        )
    imageInfoList.append(ii)
  return imageInfoList

def validateCollectionFolder(num, ftg):
  """
  Validate that the given files work as a collection. Num is the
  collection number. No files are read.
  """
  numPreviews = len(ftg.previews)
  numThumbnails = len(ftg.thumbnails)
  numJson = len(ftg.jsonFiles)
  numHtmlI = len(ftg.htmlFilesI)
  numHtmlT = len(ftg.htmlFilesT)
  numOther = len(ftg.other)

  if numPreviews == 0:
    raise MakerException(f"Error: no previews files that end in -p.jpg.")
  if numThumbnails == 0:
    raise MakerException(f"Error: no thumbnails files that end in -t.jpg.")

  if numPreviews != len(ftg.thumbnails):
    raise MakerException(
      f"Error: mismatch: {numPreviews} previews != {numThumbnails} thumbnails.")
  if numThumbnails < 8:
    raise MakerException(f"Error: {numThumbnails} images, you need at least 8.")
  if numThumbnails > 20:
    raise MakerException(f"Error: {numThumbnails} images, you are limited to 20.")
  if numJson > 1:
    raise MakerException(f"Error: {numJson} json files, expected 1.")
  if numJson == 1:
    fileInfo = ftg.jsonFiles[0]
    if fileInfo.basename != f"c{num}.json":
      raise MakerException(f"Error: invalid cjson name for this collection: {fileInfo.basename}")

  if numHtmlI > 1:
    raise MakerException(f"Error: {numHtmlI} image html files, expected 1.")
  if numHtmlI == 1:
    fileInfo = ftg.htmlFilesI[0]
    if fileInfo.basename != f"image-{num}.html" :
        raise MakerException(
          f"Error: invalid image html name for this collection: {fileInfo.basename}")

  if numHtmlT > 1:
    raise MakerException(f"Error: {numHtmlT} thumbnails html files, expected 1.")
  if numHtmlT == 1:
    fileInfo = ftg.htmlFilesT[0]
    if fileInfo.basename != f"thumbnails-{num}.html":
        raise MakerException(
          f"Error: invalid thumbnails html name for this collection: {fileInfo.basename}")

  if numOther:
    for other in ftg.other:
      # Ignore the hidden files.
      if other.basename.startswith("."):
        numOther =- 1
        continue
      first = other.basename
      raise MakerException(
        f"Error: there are {numOther} extra files in the folder, first: {first}")

def createCollectionCinfo(num, ftg, previewImageInfoList):
  """
  Create the collection info (cinfo) for the given collection number
  """
  assert len(ftg.previews) == len(ftg.thumbnails)
  images = []
  order = []

  for ix, fileInfo in enumerate(ftg.previews):
    previewFileInfo = ftg.previews[ix]
    thumbnailFileInfo = ftg.thumbnails[ix]
    previewImageInfo = previewImageInfoList[ix]

    collectionImage = {}
    collectionImage['title'] = ""
    collectionImage['description'] = ""

    collectionImage['iPreview'] = getStdImageName(num, ix, "preview")
    collectionImage['iThumbnail'] = getStdImageName(num, ix, "thumbnail")
    collectionImage['width'] = previewImageInfo.width
    collectionImage['height'] = previewImageInfo.height
    collectionImage['size'] = fileInfo.size

    collectionImage['sizet'] = thumbnailFileInfo.size
    images.append(collectionImage)
    order.append(-1)

  # Create the collection info (cinfo).
  cinfo = {
    "title": "title",
    "indexDescription": "",
    "description": "",
    "indexThumbnail": "",
    "cNum": num,
    "posted": "",
    "order": order,
    "images": images,
    "building": True,
    "ready": False,
    "zoomPoints": {},
  }
  return cinfo

def getStdImageName(num, ix, kind):
  if kind == 'preview':
    prefix = 'p'
  elif kind == 'thumbnail':
    prefix = 't'
  else:
    raise MakerException(f"Invalid kind, expected preview or thumbnail.")

  name = f"c{num}-{ix+1}-{prefix}.jpg"
  return name

def renameFiles(num, folder, ftg):
  """
  Rename the image files in the given folder to use the standard
  collection naming based on the collection number an their index.
  """
  assert len(ftg.previews) == len(ftg.thumbnails)

  # Move the previews and thumbnails to the temporary folder abc.
  tempFolder = os.path.join(folder, "abc")
  if os.path.exists(tempFolder):
    raise MakerException(f"Error: temporary folder {tempFolder} exists.")
  os.mkdir(tempFolder)
  for ix in range(len(ftg.previews)):
    oPreviewName = os.path.join(folder, ftg.previews[ix].basename)
    oThumbnailName = os.path.join(folder, ftg.thumbnails[ix].basename)

    nPreviewName = os.path.join(tempFolder, ftg.previews[ix].basename)
    nThumbnailName = os.path.join(tempFolder, ftg.thumbnails[ix].basename)

    if os.path.exists(nPreviewName):
      raise MakerException(f"Error: file {nPreviewName} exists.")
    if os.path.exists(nThumbnailName):
      raise MakerException(f"Error: file {nThumbnailName} exists.")

    os.rename(oPreviewName, nPreviewName)
    os.rename(oThumbnailName, nThumbnailName)

  # Move the temporary preview and thumbnails back to the original
  # folder and give them their standard names
  for ix in range(len(ftg.previews)):
    nPreviewName = os.path.join(tempFolder, ftg.previews[ix].basename)
    nThumbnailName = os.path.join(tempFolder, ftg.thumbnails[ix].basename)

    stdImageName = os.path.join(folder, getStdImageName(num, ix, "preview"))
    stdThumbnailName = os.path.join(folder, getStdImageName(num, ix, "thumbnail"))

    os.rename(nPreviewName, stdImageName)
    os.rename(nThumbnailName, stdThumbnailName)

  # Remove the empty temp folder.
  os.rmdir(tempFolder)

def checkNumber(s3Client, num):
  """
  Check that num is the next available number.
  """
  if num < 0:
    raise MakerException(f"Error: invalid collection number: {num}.")

  s3client = getBotoClient('s3')
  awsSettings = getAwsSettings()
  settings = awsSettings['settings']
  bucket_name = settings['bucket_name']

  # Make sure the number is not already used.
  if keyExists(s3Client, bucket_name, f"images/c{num}/c{num}.json"):
    raise MakerException("Error: the collection number is already used.")

  # Make sure the previous number is used.
  if num > 1:
    if not keyExists(s3Client, bucket_name, f"images/c{num-1}/c{num-1}.json"):
      raise MakerException("Error: the collection number is not next.")

def keyExists(s3Client, bucket_name, key):
  """
  Return true when the file exists in the s3 bucket else return false.
  """
  try:
    s3Client.head_object(Bucket=bucket_name, Key=key)
    return True
  except Exception:
    return False

def new(num):
  """
  Create a new local collection folder from a folder of images.
  """
  assert int(num) > 0

  sourceFolder = os.path.join(tmpFolder, str(num))
  if not os.path.exists(sourceFolder):
    raise MakerException(f"Missing the collection folder: {sourceFolder}")

  s3client = getBotoClient('s3')
  checkNumber(s3client, num)

  localDestFolder = f"dist/images/c{num}"
  if os.path.exists(localDestFolder):
    raise MakerException(f"The local collection folder already exists: {localDestFolder}")

  # Get names and info of all the files in the sourceFolder and
  # validate that they work in a collection.
  fileInfoList = getFileInfoList(sourceFolder)
  ftg = FileTypeGroups(fileInfoList)
  validateCollectionFolder(num, ftg)

  # Validate the image dimensions and return the preview image information.
  previewImageInfoList = getImageInfoList(sourceFolder, ftg.previews, previews=True)
  getImageInfoList(sourceFolder, ftg.thumbnails, previews=False)

  # Write the cjson file in the tmp folder.
  cinfo = createCollectionCinfo(num, ftg, previewImageInfoList)
  cjsonFilename = os.path.join(sourceFolder, f"c{num}.json")
  with open(cjsonFilename, "w") as fh:
    fh.write(json.dumps(cinfo, indent=2))

  # Rename the images in the tmp folder to their standard names.
  renameFiles(num, sourceFolder, ftg)

  # Move the tmp folder to the local images folder.
  os.rename(sourceFolder, localDestFolder)

  print(f"Created a collection folder and moved it to: {localDestFolder}")

def parseCommandLine():
  """
  Parse the command line arguments.
  """
  if len(sys.argv) == 1:
    # When there are no arguments provided, show the help information.
    sys.argv.append("-h")
  else:
    # When -t is provided, change argv so unittest does not see it.
    for ix, arg in enumerate(sys.argv[1:]):
      if arg in ['-t', '--test']:
        sys.argv.pop(ix+1)
        args = argparse.Namespace(test=True)
        return args

  # Use this module's comment at the top of the file for the
  # description.
  parser = argparse.ArgumentParser(
  prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,
  description=textwrap.dedent(__doc__))

  parser.add_argument("-t", "--test", action="store_true",
    help="""run internal unit tests""")
  parser.add_argument("-n", "--new", type=int, metavar="collectionNum",
    help="create a new local collection folder from a directory of images")

  args = parser.parse_args(sys.argv[1:])

  # Note: when -t is specified, the code doesn't reach this point.

  if "help" in args and args.help:
    parser.print_help()
    sys.exit(1)

  return args

def process(args):
  """
  Handle the maker command's options.
  """
  if args.new:
    new(args.new)

def main(args):
  def signalHandler(sig, frame):
    """ Handle ctrl-C """
    sys.exit(1)
  signal.signal(signal.SIGINT, signalHandler)
  try:
    process(args)
  except KeyboardInterrupt:
    print("\nStopping")
  except MakerException as ex:
    print(str(ex))
  except Exception as ex:
    print("Unexpected exception")
    print(traceback.format_exc())
    return 1
  return 0 # success

# Test code:

def testGetCollectionImagesError(previews, thumbnails, eMessage):
  """
  Test getCollectionImages errors, pass in the expected error message.
  """
  try:
    getCollectionImages(1, previews, thumbnails)
    assert False, "Unexpectedly passed"
  except MakerException as ex:
    gotExpected(str(ex), eMessage)
    return # passed
  assert False, "Got an unexpected exception."

def gotExpected(got, expected):
  if got != expected:
    msg = f"""
---
     got: {got}
expected: {expected}
---
"""
    assert False, msg

def pv(name, value):
  print(f"{name}: {value}")

def fail(msg):
  assert 0 == 1, msg

def testGetImageInfoError(filename, eMsg):
  """
  Test getImageInfo errors, pass in the expected error message.
  """
  try:
    ImageInfo.fromFile(filename)
    fail("Unexpectedly passed")
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")

def testValidateFolderError(num, previews=8, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, others=0, eMsg=""):
  try:
    folder = makeTestFolder(num, previews=previews, thumbnails=thumbnails,
      cjson=cjson, imageHtml=imageHtml, thumbnailHtml=thumbnailHtml, others=others)
    fileInfoList = getFileInfoList(folder)
  finally:
    shutil.rmtree(folder)

  ftg = FileTypeGroups(fileInfoList)

  try:
    validateCollectionFolder(num, ftg)
  except MakerException as ex:
    gotExpected(str(ex), eMsg)
    return # passed
  fail("Got an unexpected exception.")

def randomName(folder, k=6, prefix="", postfix=""):
  """
  Return a random name in the given folder with the
  given prefix and postfix.
  """
  randomPart = random62(k)
  return os.path.join(folder, f"{prefix}{randomPart}{postfix}")

def random62(k):
  """
  Return a random base 62 number of the given length.
  """
  characters = string.ascii_letters + string.digits
  return ''.join(random.choices(characters, k=k))

def createFile(filename, contents):
  """ Create a new file with the given contents. """
  with open(filename, 'w+', encoding='utf-8') as fh:
    fh.write(contents)

def makeTestFolder(num, previews=8, thumbnails=8, cjson=1,
  imageHtml=1, thumbnailHtml=1, others=0):
  """
  Make a collection folder in the temp dir for testing. Return the
  folder name.  When done with the folder delete it with:
  shutil.rmtree(folder)
  """

  # Create a temp folder and fill it with the specified number of fake
  # small files.

  folder = tempfile.mkdtemp(prefix="maker-")

  for ix in range(previews):
    filename = randomName(folder, 6, f"p{ix+1:02d}-", "-p.jpg")
    createFile(filename, f"fake preview file {'a' * ix}")

  for ix in range(thumbnails):
    filename = randomName(folder, 6, f"t{ix+1:02d}-", "-t.jpg")
    createFile(filename, f"fake thumbnail file {'b' * ix}")

  for ix in range(cjson):
    filename = os.path.join(folder, f"c{num+ix}.json")
    createFile(filename, f"fake cjson file {'c' * ix}")

  for ix in range(imageHtml):
    filename = os.path.join(folder, f"image-{num+ix}.html")
    createFile(filename, f"fake image html file {'d' * ix}")

  for ix in range(thumbnailHtml):
    filename = os.path.join(folder, f"thumbnails-{num+ix}.html")
    createFile(filename, f"fake thumbnail html file {'e' * ix}")

  for ix in range(others):
    filename = os.path.join(folder, f"other-{ix}.txt")
    createFile(filename, f"fake other file {'f' * ix}")

  return folder

def getTestImageInfoList(previews):
  """
  Return a list of preview image information for testing. The information is made up.
  """
  imageInfoList = []
  for ix, fileInfo in enumerate(previews):
    imageInfoList.append(ImageInfo(previewMinDim+ix, previewMinDim+ix, "JPEG"))
  return imageInfoList

class TestClients:
  def __init__(self):
    self.s3Client = getBotoClient('s3')

tc = None

def setUpModule():
  # Get the boto clients we test. This method is called once by the
  # test suite. The code is here to avoid a runtime error in the
  # shutdown phase.
  global tc
  tc = TestClients()

def tearDownModule():
  pass

class TestMaker(unittest.TestCase):
  def test_me(self):
    self.assertTrue(True)

  def test_FileInfo(self):
    fi = FileInfo("basename", isFile=True, size=0)
    eStr = "file        0 basename"
    gotExpected(str(fi), eStr)

    fi2 = FileInfo("name", isFile=False, size=1000)
    eStr2 = "-        1000 name"
    gotExpected(str(fi2), eStr2)

  def test_random62(self):
    r1 = random62(6)
    gotExpected(len(r1), 6)
    r2 = random62(10)
    gotExpected(len(r2), 10)

  def test_randomName(self):
    name = randomName("folder", 6, "prefix-", "-p.jpg")
    gotExpected(len(name), 26)
    assert name.startswith("folder/prefix-")
    assert name.endswith("-p.jpg")

  def test_createFile(self):
    folder = tempfile.mkdtemp(prefix="maker-")
    filename = os.path.join(folder, "test.txt")
    createFile(filename, "test contents")
    with open(filename, 'r', encoding='utf-8') as fh:
      contents = fh.read()
    gotExpected(contents, "test contents")
    shutil.rmtree(folder)

  def test_getStdImageName(self):
    gotExpected(getStdImageName(2, 3, "preview"), "c2-4-p.jpg")
    gotExpected(getStdImageName(23, 15, "preview"), "c23-16-p.jpg")
    gotExpected(getStdImageName(2, 3, "thumbnail"), "c2-4-t.jpg")
    gotExpected(getStdImageName(23, 15, "thumbnail"), "c23-16-t.jpg")

  def test_makeTestFolder(self):
    num = 4
    folder = makeTestFolder(num)
    assert os.path.exists(folder)
    # pv("folder", folder)
    fileInfoList = getFileInfoList(folder)
    # for ix, fileInfo in enumerate(fileInfoList):
    #   pv("fileInfo", str(fileInfo))
    # print("")
    ftg = FileTypeGroups(fileInfoList)
    shutil.rmtree(folder)

    gotExpected(len(ftg.previews), 8)
    gotExpected(len(ftg.thumbnails), 8)
    gotExpected(len(ftg.jsonFiles), 1)
    gotExpected(len(ftg.htmlFilesI), 1)
    gotExpected(len(ftg.htmlFilesT), 1)

    gotExpected(str(ftg.jsonFiles[0]),  "file       16 c4.json")
    gotExpected(str(ftg.htmlFilesI[0]), "file       21 image-4.html")
    gotExpected(str(ftg.htmlFilesT[0]), "file       25 thumbnails-4.html")

    for ix, fileInfo in enumerate(ftg.previews):
      # fileInfo: file       18 p01-kw34Ml-p.jpg
      gotExpected(len(str(fileInfo)), 30)
      gotExpected(str(fileInfo)[0:18], f"file       {18+ix} p{ix+1:02d}-")
      gotExpected(str(fileInfo)[-6:], "-p.jpg")

    for ix, fileInfo in enumerate(ftg.thumbnails):
      # fileInfo: file       20 t01-0PeLgR-t.jpg
      gotExpected(len(str(fileInfo)), 30)
      gotExpected(str(fileInfo)[0:18], f"file       {20+ix} t{ix+1:02d}-")
      gotExpected(str(fileInfo)[-6:], "-t.jpg")

  def test_makeTestFolderAll(self):
    folder = makeTestFolder(4, previews=1, thumbnails=2, cjson=3,
      imageHtml=4, thumbnailHtml=5, others=6)
    assert os.path.exists(folder)
    # pv("folder", folder)
    fileInfoList = getFileInfoList(folder)
    ftg = FileTypeGroups(fileInfoList)
    shutil.rmtree(folder)
    gotExpected(len(ftg.previews), 1)
    gotExpected(len(ftg.thumbnails), 2)
    gotExpected(len(ftg.jsonFiles), 3)
    gotExpected(len(ftg.htmlFilesI), 4)
    gotExpected(len(ftg.htmlFilesT), 5)
    gotExpected(len(ftg.other), 6)

  def test_dim(self):
    gotExpected(thumbnailDim, 480)
    gotExpected(previewMinDim, 933)

  def test_ImageFile(self):
    previewName = "dist/images/c1/c1-1-p.jpg"
    pii = ImageInfo.fromFile(previewName)
    gotExpected(pii.kind, "JPEG")
    gotExpected(pii.width, 3024)
    gotExpected(pii.height, 4032)
    gotExpected(str(pii), "JPEG (3024 x 4032)")

    thumbnailName = "dist/images/c1/c1-1-t.jpg"
    tii = ImageInfo.fromFile(thumbnailName)
    gotExpected(tii.kind, "JPEG")
    gotExpected(tii.width, 480)
    gotExpected(tii.height, 480)
    gotExpected(str(tii), "JPEG (480 x 480)")

  def test_ImageFile_transposed(self):
    # test(fn, createTestImage(8, 1, 3024, 4032, 3871458, 70466))
    previewName = "dist/images/c8/c8-1-p.jpg"
    pii = ImageInfo.fromFile(previewName)
    gotExpected(pii.kind, "JPEG")
    gotExpected(pii.width, 3024)
    gotExpected(pii.height, 4032)
    gotExpected(str(pii), "JPEG (3024 x 4032)")


  def test_ImageFileMissing(self):
    try:
      ImageInfo.fromFile("missing")
      assert False, "Unexpectedly passed"
    except MakerException as ex:
      gotExpected(str(ex), "Error: unable to open the image file: missing")

  def test_getImageInfoList(self):
    folder = "dist/images/c1"
    fileInfoList = getFileInfoList(folder)
    ftg = FileTypeGroups(fileInfoList)
    piiList = getImageInfoList(folder, ftg.previews, previews=True)
    gotExpected(len(piiList), 8)
    getImageInfoList(folder, ftg.thumbnails, previews=False)
    # for ix, pii in enumerate(piiList):
    #  pv("pii", pii)
    gotExpected(len(piiList), 8)

  def test_keyExists(self):
    if not internet:
      return
    bucket_name = "sflennikco"
    assert keyExists(tc.s3Client, bucket_name, "images/c1/c1-1-p.jpg") == True
    assert keyExists(tc.s3Client, bucket_name, "images/c1/c1-1-t.jpg") == True
    assert keyExists(tc.s3Client, bucket_name, "images/c1/xyz.jpg") == False

  def test_checkNumber(self):
    if not internet:
      return
    return

    checkNumber(tc.s3Client, 4)

    with self.assertRaises(MakerException):
      checkNumber(tc.s3Client, 3)

    with self.assertRaises(MakerException):
      checkNumber(tc.s3Client, 5)

  def test_getFileInfoList(self):
    fileInfoList = getFileInfoList("dist")
    self.assertTrue(len(fileInfoList) > 0)
    found = 0
    for fileInfo in fileInfoList:
      # pv('fileInfo', fileInfo)
      if fileInfo.basename == "index.html":
        found += 1
      elif fileInfo.basename == "images":
        found += 1
    gotExpected(found, 2)

  def test_getImageInfo(self):
    previewFile = "/home/coder/collections/dist/images/c1/c1-1-p.jpg"
    imageInfo = ImageInfo.fromFile(previewFile)
    gotExpected(imageInfo.kind, "JPEG")
    gotExpected(imageInfo.width, 3024)
    gotExpected(imageInfo.height, 4032)

    thumbnailFile = "/home/coder/collections/dist/images/c1/c1-1-t.jpg"
    info = ImageInfo.fromFile(thumbnailFile)
    # pv('thumbnailImageInfo', thumbnailImageInfo)
    gotExpected(info.kind, "JPEG")
    gotExpected(info.width, 480)
    gotExpected(info.height, 480)

  def test_getImageInfoNoFile(self):
    # Test with missing file.
    testGetImageInfoError("missing", "Error: unable to open the image file: missing")

  def test_getImageInfoNotImage(self):
    # Test with non-image file
    htmlFile = "dist/index.html"
    eMsg = "Error: unable to open the image file: dist/index.html"
    testGetImageInfoError(htmlFile, eMsg)

  def test_validateFolder(self):
    c1 = "/home/coder/collections/dist/images/c1"
    fileInfoList = getFileInfoList(c1)
    ftg = FileTypeGroups(fileInfoList)
    validateCollectionFolder(1, ftg)

  def test_validateFolderUnmatched(self):
    eMsg = "Error: mismatch: 8 previews != 9 thumbnails."
    testValidateFolderError(4, previews=8, thumbnails=9, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolder7(self):
    eMsg = "Error: 7 images, you need at least 8."
    testValidateFolderError(4, previews=7, thumbnails=7, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolder21(self):
    eMsg = "Error: 21 images, you are limited to 20."
    testValidateFolderError(4, previews=21, thumbnails=21, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderExtra(self):
    eMsg = "Error: there are 2 extra files in the folder, first: other-0.txt"
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg, others=2)

  def test_validateFolderNoPreviews(self):
    eMsg = "Error: no previews files that end in -p.jpg."
    testValidateFolderError(4, previews=0, thumbnails=8, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderNoThumbs(self):
    eMsg = "Error: no thumbnails files that end in -t.jpg."
    testValidateFolderError(4, previews=8, thumbnails=0, cjson=0,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderCjson(self):
    eMsg = "Error: 2 json files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=2,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderCjson1(self):
    eMsg = "Error: 2 json files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=2,
      imageHtml=0, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderPreHtml(self):
    eMsg = "Error: 3 image html files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=1,
      imageHtml=3, thumbnailHtml=0, eMsg=eMsg)

  def test_validateFolderThumbHtml(self):
    eMsg = "Error: 2 thumbnails html files, expected 1."
    testValidateFolderError(4, previews=8, thumbnails=8, cjson=1,
      imageHtml=1, thumbnailHtml=2, eMsg=eMsg)

  def test_createCollectionCinfo(self):
    num = 3
    try:
      folder = makeTestFolder(num, previews=8, thumbnails=8,
        cjson=0, imageHtml=0, thumbnailHtml=0, others=0)
      fileInfoList = getFileInfoList(folder)

      ftg = FileTypeGroups(fileInfoList)
      validateCollectionFolder(num, ftg)

      previewImageInfoList = getTestImageInfoList(ftg.previews)

      cinfo = createCollectionCinfo(num, ftg, previewImageInfoList)
      cjson = json.dumps(cinfo, indent=2)
      # print(cjson)

      gotExpected(cinfo['title'], "title")
      gotExpected(cinfo['indexDescription'], "")
      gotExpected(cinfo['cNum'], num)
      gotExpected(cinfo['building'], True)
      gotExpected(cinfo['ready'], False)
      # gotExpected(len(cinfo['order']), 0)
      # gotExpected(len(cinfo['images']), 8)
      for ix, image in enumerate(cinfo['images']):
        #print(json.dumps(image, indent=2))
        gotExpected(image['title'], "")
        gotExpected(image['description'], "")
        gotExpected(image['iPreview'], getStdImageName(num, ix, "preview"))
        gotExpected(image['iThumbnail'], getStdImageName(num, ix, "thumbnail"))
        # self.assertTrue(image['iPreview'].startswith(f"p{ix+1:02d}-"))
        # self.assertTrue(image['iPreview'].endswith("-p.jpg"))
        # self.assertTrue(image['iThumbnail'].startswith(f"t{ix+1:02d}-"))
        # self.assertTrue(image['iThumbnail'].endswith("-t.jpg"))
        gotExpected(image['width'], 933+ix)
        gotExpected(image['height'], 933+ix)
        gotExpected(image['size'], 18+ix)
        gotExpected(image['sizet'], 20+ix)

      renameFiles(num, folder, ftg)

      fileInfoList = getFileInfoList(folder)

      ftg = FileTypeGroups(fileInfoList)

      for ix, fileInfo in enumerate(ftg.previews):
        # pv('fileInfo', fileInfo)
        gotExpected(fileInfo.basename, getStdImageName(num, ix, "preview"))
      for ix, fileInfo in enumerate(ftg.thumbnails):
        # pv('fileInfo', fileInfo)
        gotExpected(fileInfo.basename, getStdImageName(num, ix, "thumbnail"))

      validateCollectionFolder(num, ftg)

    finally:
      shutil.rmtree(folder)

  def test_createCollectionCinfo_max(self):
    """
    Test that the new collection json keys match the existing json keys.
    """
    num = 4
    try:
      folder = makeTestFolder(num, previews=20, thumbnails=20,
        cjson=0, imageHtml=0, thumbnailHtml=0, others=0)
      fileInfoList = getFileInfoList(folder)

      ftg = FileTypeGroups(fileInfoList)
      validateCollectionFolder(num, ftg)

      previewImageInfoList = getTestImageInfoList(ftg.previews)

      cinfoNew = createCollectionCinfo(num, ftg, previewImageInfoList)
    finally:
      shutil.rmtree(folder)

    with open("dist/images/c3/c3.json", 'r') as file:
      cinfo3 = json.load(file)

    newKeys = cinfoNew.keys()
    c3Keys = cinfo3.keys()

    # print("new keys:")
    # print(cinfoNew.keys())
    # print("c3 keys:")
    # print(cinfo3.keys())

    success = True
    for c3Key in c3Keys:
      if c3Key not in newKeys:
        if c3Key == "zoomPoints":
          continue
        print(f"c3Key '{c3Key}' not in newKeys.")
        success = False

    for newKey in newKeys:
      if newKey not in c3Keys:
        if newKey in ["order", "building"]:
          continue
        print(f"newKey '{newKey}' not in c3Keys.")
        success = False

    c3FirstImageKeys = cinfo3['images'][0].keys()
    newFirstImageKeys = cinfoNew['images'][0].keys()

    for c3FirstImageKey in c3FirstImageKeys:
      if c3FirstImageKey not in newFirstImageKeys:
        print(f"c3FirstImageKey '{c3FirstImageKey}' not in newFirstImageKeys.")
        success = False

    for newFirstImageKey in newFirstImageKeys:
      if newFirstImageKey not in c3FirstImageKeys:
        print(f"newFirstImageKey '{newFirstImageKey}' not in c3FirstImageKeys.")
        success = False

    self.assertTrue(success)

if __name__ == '__main__':
  args = parseCommandLine()
  if args.test:
    sys.exit(unittest.main())
  rc = main(args)
  sys.exit(rc)
